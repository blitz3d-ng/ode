
TODO
----

what i'm doing now: joints:
	hinge
		measure angle, rate - DONE
		power - DONE
		joint limits
		optional suspension:
			alignment of B&S part to given axis
			global framework for giving epsilon and gamma

	toss away r-motor, power & stuff specific to joint. it's just easier
	that way.

	r-motor joint needs to measure motor angle and vel, fn to get this info
		* angle done. but the angle reading is wrong if the rmotor is
		  used on a steering hinge (hinge2) and the wheel is moved on
		  the steering axis.
	r-motor joint needs stops (low and high)
	make sure rmotor works with just one body and static env.
	joint code reuse: use standard functions to set velocity (c),
		limits (lo,hi), spongyness (epsilon) etc, this prevents these
		functions from proliferating.
	linear motor
	implicit spring framework - actually allow joints to return a value `k'
		such that J*vnew = c + k*f, where f = force needed to achieve
		vnew.
	contact slip
	more joint code reuse - setting axes etc??
	hinge and hinge2 joints need to have orientable ball-and-socket parts,
		to allow directed suspension axes. suspension axis must have
		stops - implement this with a separate joint??
	more joints: spring, planar, fixed path, etc etc.

andy says: still having trouble with those resource files..
drawstuff.res doesn't seem to build or be found under cygwin gcc.
andy says: in ode/src/error.cpp _snprintf() and _vsnprintf() are missing
in testode: finite and isnan are missing. copysign is missing
	russ: okay here's the problem: i have Makefile.platform files for
	VC++, MinGW, but not Cygwin. Cygwin uses the unix-like functions
	for everything, but the VC++/MinGW configs assumes the MS C-runtime
	functions. this is easy to fix, except i need to install Cygwin
	which is a pain to do over MinGW. argh.

build on linux - assumptions made about location of X11 lib, opengl etc.
use autoconf?

hinge2 needs to be attached to two bodies for it to work, make sure this is
always the case.

make sure joints can return 0 from GetInfo1, i.e. no constraints or "inactive"
joint, and the step functions will handle it.

check inertia transformations, e.g. by applying steering torque to a thin
wheel.

dAlloc() should take an arena parameters which is stored in dWorld.

debugging mode should use dASSERT2 that prints a descriptive error message
on error, not just the file:line or function. use dASSERT for internal
consistency checking.

if two joints connect to the same two bodies, check that the fast solver
works!

doccer: @func{} also refs second etc function in function *list*.

better stack implementation that is not so system dependent. but how will
we do dynamic page allocation? do we even need to?

when vectors and matrices are initialized, we must ensure that the padding
elements are set to 0. this is going to be a problem everywhere!

don't use 3-vectors anywhere. use SIMD friendly 4-vectors.

make sure all data in body/joint etc objects is aligned well for single
precision SIMD (i.e. all vectors start on a 16 byte boundary).

think about more complicated uses of collision, e.g. a single geom representing
an articulated structure.

bodyGroup? (like joint group but for bodies). systemGroup?

check the overhead of resizing Array<>s as elements are pushed on to them.

replace alloca() with dPushFrame(), dPopFrame(), and dAlloca() ? allow for
the possibility of allocating in non-stack memory ?

make sure that we can set mass parameters with non-zero center of mass.
if this is done after the body position is set, the position is adjusted.
if this is done before the body position is set, what do we do when the
pos is set? does the pos always refer to the center of mass from the user's
point of view?

more comprehensive random number comparisons between slow and fast methods.
	- random PD inertia (not just diagonal).
	- random velocity
	- random joint error (make joints then move bodies a bit)

consider splitting solver into functions, which can be optimized separately.
might make things go faster.

spaces need multiple lists of objects that can never overlap. objects in these
lists are never tested against each other.

space near-callback should be given potentially intersecting objects 100 at a
time instead of 1 at a time, to save on calling costs.

faster code for islands with a single body? faster code for dynamically
symmetric bodies?

joint groups should also be destroyed by destroying the world.

when attaching contact with (0,body), instead of setting the reverse flag
on the joint and checking it in getInfo2(), we should just reverse the normal
straight away ... ?

rotation.cpp functions that set matrices should also set padding elements.

functions to get body connectedness (e.g. return joint lists). also for joints.

check that J*vnew=c (slow step already does this, but it doesn't equal zero
for some reason!)

lcp solver must return (L,d) and some other information, so we can re-solve
for other right hand sides later on, but using the same complimentarity
solution so there are no integrator discontinuities.

tons of things in lcp.cpp (@@@), especially speed optimizations. also, do
index block switching and index block updates to take advantage of the outer
product trick.

dSetZero() - make fast inline functions for fixed n e.g. (1-4).

need proper `sticky' friction, i.e. compensation for numerical slip.

dJointAttach(), allow both bodies to be 0 to put the joint into limbo.

timer reporting function:
	void timerReport (void (*printFunction)(char *, ...));

on windows, make sure gcc-compiles libs can be linked with VC++ apps. need
to make sure some C++ runtime bits are present.

kill all references to dArray<> (in geom.cpp).

need testing code to test all joints with body-to-static-env


ALWAYS
------

make sure functions check their arguments in debug mode (e.g. using dASSERT).
make sure joint/geom functions check for the specific object type.

vectors alloca()ed on the stack must have the correct alignment, use ALLOCA16.

library should have no global constructors, as it might be used with C linkage.

use `const' in function arguments. blah.



DONE
----

check: when contact attached with (body1,0) and (0,body1), check that polarity
on depth and error info is okay for the two cases.

set a better convention for which is the 1st and 2nd body in a joint, because
sometimes we get things swapped (because of the way the joint nodes are used).

hinge and prismatic, attachment to static environment.

turn macros into C++ inline functions? what about C users?

remove `space' argument to geom creation functions? make user add it?
or just remove it from dCreateGeom() ?  <-- did this one.

test_chain should be in C, not C++. but first must remove global constructors.

add more functionality to C++ interface - dMass, dSpace, dGeom

there should be functions to delete groups of bodies/joints in one go - this
will be more efficient than deleting them one at a time, because less
partitioning tests will be needed.

should we expose body and joint object structures so that the user can
explicitly allocate them locally, or e.g. on the stack? makes allocating
temporary contact constraints easier. NO --> helps data hiding and therefore
library binary compatability.
