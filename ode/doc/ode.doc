
@title{Open Dynamics Engine v0.03 User Guide}
@subtitle{Russell Smith, @date{}}
@author{Russell Smith, @date{}}

@center{This document is Copyright &copy 2001 Russell Smith.}
@center{This is an UNFINISHED document}

@chapter{Contents @nonumber @nocontents}
@contents

#############################################################################
@chapter{Introduction}

The Open Dynamics Engine (ODE) is a free, industrial quality library for
simulating articulated rigid body dynamics.
For example, it is good for simulating ground vehicles, legged creatures,
and moving objects in VR environments.
It is fast, flexible and robust, and it has built-in collision detection.
ODE is being developed by @link{http://www.q12.org}{Russell Smith}.

If ``rigid body simulation'' does not make much sense to you, check out
@link{http://www.q12.org/ode/slides/slides.html}{What is a Physics SDK?}.

The is the user guide for the third prototype release of ODE (version 0.03).
This release is to help continue testing the core algorithms and solidifying
the API.
There will probably only be a few (hopefully minor) changes to the API in
the future.


@section{Current features}

ODE is best for simulating @emph{articulated} rigid body structures.
An articulated structure is created when rigid bodies of various shapes are
connected together with joints of various kinds.
Examples are ground vehicles (where the wheels are connected to the chassis)
or legged creatures (where the legs are connected to the body).

ODE is designed to be used in interactive or realtime simulation.
It is particularly good for simulating moving objects in changable
virtual reality environments.
This is because it is fast, robust and stable, and the user has complete
freedom to change the structure of the system even while the simulation
is running.

# ODE can of course also simulate disconnected rigid bodies that just move
# around on their own and perhaps collide with each other, but it is not
# optimized for this case.
#    --- but it will be!

ODE uses a highly stable integrator, so that the simulation errors should
not grow out of control.
The physical meaning of this is that the simulated system should not
"explode" for no reason (believe me, this happens a lot with other simulators
if you are not careful).
ODE emphasizes speed and stability over physical accuracy.

ODE has @emph{hard} contacts. This means that a special non-penetration
constraint is used whenever two bodies collide.
The alternative, used in many other simulators, is to use virtual springs to
represent contacts.
This is difficult to do right and extremely error-prone.

ODE has a built-in collision detection system.
However you can ignore it and do your own collision detection if you want to.
The current collision primitives are sphere, box and plane - more collision
objects will come later, as well as fast identification of potentially
intersecting objects.

Here are the features:
@list{
@*	Arbitrary mass distribution of the rigid bodies.
@*	Current joint types: ball-and-socket, hinge, slider (prismatic),
	hinge-2, fixed.
@*	Current collision primitives: sphere, box and plane.
@*	Simulation method: The equations of motion are derived from a
	Lagrange multiplier velocity based model due to Trinkle/Stewart and
	Anitescu/Potra.
@*	A first order integrator is being used. It's fast, but not accurate
	enough for quantitative engineering yet. Higher order integrators
	will come later.
@*	Contact and friction model: This is based on the Dantzig LCP solver
	described by Baraff, although ODE implements a faster approximation
	to the Coloumb friction model.
@*	Has a native C interface (even though ODE is mostly written in C++).
@*	Has a C++ interface built on top of the C one.
@*	Many unit tests, and more being written all the time.
@*	Platform specific optimizations.
@*	Other stuff I forgot to mention...
}

@section{New in the 0.02 release}

@list{
@* New demo: a box and sphere stacker.
@* Collision framework nearing stability.
@* Collision: all interactions of sphere, box, and plane now work.
@* 2D & 3D friction now works.
@* Framework now in place for more contact modes, powered and limited joints.
@* Moving-surface contact mode.
@* Argument checking for all functions.
@* Cross platform: build on windows using VC++ and MinGW, and linux.
@* Various bugs fixed.
}

One current problem is that the @c{mu} parameter that controls Coulomb friction
is not yet interpreted correctly - it specifies the maximum friction force
that can be present at a contact, rather than specifying the maximum ratio of
tangential to normal force. This will be fixed in the next release.
[Note: I need lots more documentation about how the friction approximation
works].


@section{New in the 0.03 release}

@list{
@* Numerous bug fixes, including contacts.
@* Updated documentation.
@* Joint types: hinge, slider, ball and socket, hinge-2, fixed, contact.
@* Special vehicle joint: hinge-2 - with steering and suspension.
@* Powered hinge and slider joints (plus dry friction in those joints).
@* Joint limits for hinge and slider.
@* All contact modes work: bounce, soft, slip, restitution, tyre slip.
@* CFM (constraint force mixing) framework.
}


@section{Future features}

@subsection{Plan for 0.03 release}

@list{
@* Update documentation.
@* Improve the approximation to Coloumb friction.
@* High level functions that create dynamics and collision objects together.
@* Optimize LCP solver even more.
@* Expose type-specific collision functions.
@* More collision primitives: capped cylinder, composite objects.
@* Improve box-box collision, especially for face-face contact.
@* Some internals documentation.
@* Automatic code optimization process.
@* Collision space: quick identification of potentially intersecting pairs.
}

@subsection{Plan for 0.04 release}

@list{
@* Update documentation.
@* Static (still) groups not simulated.
@* SSE and 3DNow optimizations.
@* Implicit body damping, with reference velocity.
@* More collision primitives: flat-end cylinder, cone?
@* Higher order integrators for higher accuracy. Also force callback functions.
@* More internals documentation.
@* More joints.
@* All joints powered with limits.
}

@subsection{Other stuff for later releases}

@list{
@* Simulation tutorial, full documentation of internals and methods.
@* Collision: polyhedral objects, triangle soup.
@* Add reduced coordinate methods for a major speed improvement on
   tree-structured systems.
@* Thread safe.
}


@section{ODE's license}

ODE is Copyright &copy; 2001 Russell Smith.

This library is free software; you can redistribute it and/or
modify it under the terms of the @link{http://www.opensource.org/licenses/lgpl-license.html}{GNU Lesser General Public License}
as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but @emph{WITHOUT ANY WARRANTY}; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.


@section{Call for volunteers}

Think you can help? Please @link{http://www.q12.org}{write to me}.

#############################################################################
@chapter{Concepts}

@section{Background}

[Here is where I will write some background information about rigid body
dynamics and simulation.
But in the meantime, please refer to Baraff's excellent
@link{http://www.cs.cmu.edu/~baraff/sigcourse/index.html}{SIGGRAPH tutorial}].


@section{Rigid bodies}

A rigid body has various properties from the point of view of the simulation.
Some properties change over time:
@list{
@*	Position vector (x,y,z) of the body's point of reference.
	Currently the point of reference must correspond to the body's
	center of mass.
@*	Linear velocity of the point of reference, a vector (vx,vy,vz).
@*	Orientation of a body, represented by a quaternion (qs,qx,qy,qz) or
	a 3x3 rotation matrix.
@*	Angular velocity vector (wx,wy,wz) which describes how the orientation
	changes over time.

}
Other body properties are usually constant over time:
@list{
@*	Mass of the body.
@*	Position of the center of mass with respect to the point of reference.
	In the current implementation the center of mass and the point of
	reference must coincide.
@*	Inertia matrix. This is a 3x3 matrix that describes how the body's
	mass is distributed around the center of mass.
}
Conceptually each body has an x-y-z coordinate frame embedded in it, that moves
and rotates with the body:

		@center{@picture{pix/body.jpg}}

The origin of this coordinate frame is the body's point of reference.
Some values in ODE (vectors, matrices etc) are relative to the body
coordinate frame, and others are relative to the global coordinate frame.

Note that the @emph{shape} of a rigid body is not a dynamical properties
(except insofar as it influences the various mass properties).
It is only @emph{collision detection} that cares about the detailed shape of
the body.


@section{Integration}

The process of simulating the rigid body system through time is called
integration.
Each integration step advances the current time by a given step size,
adjusting the state of all the rigid bodies for the new time value.
There are two main issues to consider when working with any integrator:
@list{
@*	How accurate is it? That is, how closely does the behavior of the
	simulated system match what would happen in real life?
@*	How stable is it? That is, will calculation errors ever cause
	completely non-physical behavior of the simulated system?
	(e.g. causing the system to "explode" for no reason).
}
ODE's current integrator is very stable, but not particularly accurate
unless the step size is small.
For most uses of ODE this is not a problem -- ODE's behavior still looks
perfectly physical in almost all cases.
However ODE should not be used for quantative engineering until this accuracy
issue has been addressed in a future release.


@section{Force accumulators}

Between each integrator step the user can call functions to apply forces
to the rigid body.
These forces are added to "force accumulators" in the rigid body object.
When the next integrator step happens, the sum of all the applied forces
will be used to push the body around.
The forces accumulators are set to zero after each integrator step.


@section{Joints and constraints}

In real life a joint is something like a hinge, that is used to connect two
objects.
In ODE a joint is very similar: It is a relationship that is enforced between
two bodies so that they can only have certain positions and orientations
relative to each other.
This relationship is called a @emph{constraint} -- the words @emph{joint} and
@emph{constraint} are often used interchangably.
The following picture shows three different constraint types:

		@center{@picture{pix/joints.jpg}}

The first is a ball and socket joint that constraints the ``ball'' of one
body to be in the same location as the ``socket'' of another body.
The second is a hinge joint that constraints the two parts of the
hinge to be in the same location and to line up along the hinge axle.
The third is a slider joint that constraints the ``piston'' and ``socket''
to line up, and additionally constraints the two bodies to have the same
orientation.

Each time the integrator takes a step all the joints are allowed to apply
@emph{constraint forces} to the bodies they affect.
These forces are calculated such that the bodies move in such a way to
preserve all the joint relationships.

Each joint has a number of parameters controlling its geometry.
An example is the position of the ball-and-socket point for a ball-and-socket
joint.
The functions to set joint parameters all take @emph{global} coordinates,
not body-relative coordinates.
A consequence of this is that the rigid bodies that a joint connects must be
positioned correctly @emph{before} the joint is attached.


@section{Joint groups}

A joint group is a special container that holds joints in a world.
Joints can be added to a group, and then when those joints are no
longer needed the entire group of joints can be very quickly destroyed
with one function call.
However, individual joints in a group can not be destroyed before the entire
group is emptied.

This is most useful with contact joints, which are added and remove from
the world in groups every time step.


@section{Joint error and the error reduction parameter}

When a joint attaches two bodies, those bodies are required to have certain
positions and orientations relative to each other.
However, it is possible for the bodies to be in positions where the joint
constraints are not met.
This ``joint error'' can happen in two ways:
@numlist{
@*	If the user sets the position/orientation of one body without correctly
	setting the position/orientation of the other body.
@*	During the simulation, errors can creep in that result in the bodies
	drifting away from their required positions.
}
Here is an example of error in a ball and socket joint (where the ball and
socket do not line up):

		@center{@picture{pix/ball-and-socket-bad.jpg}}

There is a mechanism to reduce joint error: during each simulation step each
joint applies a special force to bring its bodies back into correct alignment.
This force is controlled by the @emph{error reduction parameter} (ERP),
which has a value between 0 and 1.

The ERP specifies what proportion of the joint error will be
fixed during the next simulation step.
If ERP=0 then no correcting force is applied and the bodies will eventually
drift apart as the simulation proceeds.
If ERP=1 then the simulation will attempt to fix all joint error during the
next time step.
However, setting ERP=1 is not recommended, as the joint error will not be
completely fixed due to various internal approximations.
A value of ERP=0.1 to 0.8 is recommended (0.2 is the default).

A global ERP value can be set that affects most joints in the simulation.
However some joints have local ERP values that control various aspects of
the joint.


@section{Constraint force mixing (CFM)}

Traditionally the constraint equation for every joint has the form

	@center{@m{J * v = c}}

where @m{v} is a velocity vector for the bodies involved, @m{J} is a
``Jacobian'' matrix with one row for every degree of freedom the joint
removes from the system, and @m{c} is a right hand side vector.
At the next time step, a vector @m{lambda} is calculated (of the same
size as @m{c}) such that the forces applied to the bodies to preserve the
joint constraint are

	@center{@m{force = J^T * lambda}}

ODE adds a new twist.
ODE's constraint equation has the form

	@center{@m{J * v = c + CFM * lambda}}

where @m{CFM} is a square diagonal matrix.
@m{CFM} mixes the resulting constraint force in with the constraint that
produces it.
By using @m{CFM} you can model tyre slip, suspension, soft ground and other
things.

Solving for @m{lambda} gives

	@center{@m{(J M^-^1 J^T + CFM/h) lambda = c/h}}

Thus @m{CFM} simply adds to the diagonal of the original system matrix.
This has the additional benefit of taking the system away from singularity
and improving factorizer accuracy.

[write more...]


@section{Collision handling}

[There is a lot that needs to be written about collision handling.]

Collisions between bodies or between bodies and the static environment are
handled as follows:
@numlist{
@*	Before each simulation step, the user calls collision detection
	functions to determine what is touching what.
	These functions return a list of contact points.
	Each contact point specifies a position in space, a surface normal
	vector, and a penetration depth.

@*	A special contact joint is created for each contact point.
	The contact joint is given extra information about the contact,
	for example the friction present at the contact surface, how bouncy
	or soft it is, and various other properties.

@*	The contact joints are put in a joint "group", which allows them to be
	added to and removed from the system very quickly.
	The simulation will speed goes down as the number of contacts goes up,
	so various strategies can be used to limit the number of contact
	points.

@*	A simulation step is taken.

@*	All contact joints are removed from the system.
}
Note that the built-in collision functions do not have to be used -
other collision detection libraries can be used as long as they provide
the right kinds of contact point information.


@section{Typical simulation code}

A typical simulation will proceed like this:
@numlist{
@*	Create a dynamics world.
@*	Create bodies in the dynamics world.
@*	Set the state (position etc) of all bodies.
@*	Create joints in the dynamics world.
@*	Attach the joints to the bodies.
@*	Set the parameters of all joints.
@*	Create a collision world and collision geometry objects, as
	necessary.
@*	Create a joint group to hold the contact joints.
@*	Loop: @numlist{
	@*	Apply forces to the bodies as necessary.
	@*	Adjust the joint parameters as necessary.
	@*	Call collision detection.
	@*	Create a contact joint for every collision point, and put it
		in the contact joint group.
	@*	Take a simulation step.
	@*	Remove all joints in the contact joint group.
	}
@*	Destroy the dynamics and collision worlds.
}


@section{Physics model}

[Discuss the various methods and approximations that are used.]

#############################################################################
@chapter{Data types and conventions}

@section{The basic data types}

The ODE library can be built to use either single or double precision floating
point numbers.
Single precision is faster and uses less memory, but the simulation will
have more numerical error that can result in visible problems.
You will get less accuracy and stability with single precision.

[must describe what factors influence accuracy and stability].

The floating point data type is @c{dReal}.
Other commonly used types are @c{dVector3}, @c{dVector4}, @c{dMatrix3},
@c{dMatrix4}, @c{dQuaternion}.


@section{Objects and IDs}

There are various kinds of object that can be created:
@list{
@*	dWorld - a dynamics world.
@*	dSpace - a collision space.
@*	dBody - a rigid body.
@*	dGeom - geometry (for collision).
@*	dJoint - a joint
@*	dJointGroup - a group of joints.
}
Functions that deal with these objects take and return object IDs.
The object ID types are @c{dWorldID}, @c{dBodyID}, etc.


@section{Argument conventions}

All 3-vectors (x,y,z) supplied to ``set'' functions are given as individual
x,y,z arguments.

All 3-vector result arguments to get() function are pointers to arrays of
@c{dReal}.

Larger vectors are always supplied and returned as pointers to arrays of
@c{dReal}.

All coordinates are in the global frame except where otherwise specified.


@section{C versus C++}

The ODE library is written in C++, but its public interface is made of simple
C functions, not classes. Why is this?
@list{
@*	Using a C interface only is simpler - the features of C++ features do
	not help much for ODE.
@*	It prevents C++ mangling and runtime-support problems across multiple
	compilers.
@*	The user doesn't have to be familiar with C++ quirks to use ODE.
}


@section{Debugging}

The ODE library can be compiled in "debugging" or "release" mode.
Debugging mode is slower, but function arguments are checked and many
compile-time tests are done to ensure internal consistency.
Release mode is faster, but no checking is done.

#############################################################################
@chapter{World}

The world object is a container for rigid bodies and joints.

@funcdef{
dWorldID dWorldCreate();
}{
Create a new, empty world and return its ID number.
}


@funcdef{
void dWorldDestroy (dWorldID);
}{
Destroy a world and everything in it.
}


@funcdef{
void dWorldSetGravity (dWorldID, dReal x, dReal y, dReal z);
void dWorldGetGravity (dWorldID, dVector3 gravity);
}{
Set and get the world's global gravity vector. The units are m/s/s, so Earth's
gravity vector would be (0,0,-9.81), assuming that +z is up.
The default is no gravity, i.e. (0,0,0).
}


@funcdef{
void dWorldSetERP (dWorldID, dReal erp);
dReal dWorldGetERP (dWorldID);
}{
Set and get the global ERP value, that controls how much error correction is
performed in each time step.
Typical values are in the range 0.1--0.8.
The default is 0.2.
}


@funcdef{
void dWorldSetCFM (dWorldID, dReal cfm);
dReal dWorldGetCFM (dWorldID);
}{
Set and get the global CFM (constraint force mixing) value.
Typical values are in the range 1e-9 -- 1.
The default is 1e-5 if single precision is being used, or 1e-10 if double
precision is being used.
}


@funcdef{
void dWorldStep (dWorldID, dReal stepsize);
}{
Step the world.
}


#############################################################################
@chapter{Rigid body functions}

@funcdef{
dBodyID dBodyCreate (dWorldID);
}{
Create a body in the given world with default mass parameters at
position (0,0,0).
Return its ID.
}


@funcdef{
void dBodyDestroy (dBodyID);
}{
Destroy a body.
All joints that are attached to this body will be put into limbo
(i.e. unattached and not affecting the simulation, but they will NOT be
deleted).
}


@funcdef{
void  dBodySetData (dBodyID, void *data);
void *dBodyGetData (dBodyID);
}{
Get and set the body's user-data pointer.
}


@funcdef{
void dBodySetPosition   (dBodyID, dReal x, dReal y, dReal z);
void dBodySetRotation   (dBodyID, const dMatrix3 R);
void dBodySetQuaternion (dBodyID, const dQuaternion q);
void dBodySetLinearVel  (dBodyID, dReal x, dReal y, dReal z);
void dBodySetAngularVel (dBodyID, dReal x, dReal y, dReal z);
const dReal * dBodyGetPosition   (dBodyID);
const dReal * dBodyGetRotation   (dBodyID);
const dReal * dBodyGetQuaternion (dBodyID);
const dReal * dBodyGetLinearVel  (dBodyID);
const dReal * dBodyGetAngularVel (dBodyID);
}{
These functions set and get the position, rotation, linear and angular
velocity of the body.
After setting a group of bodies, the outcome of the simulation is undefined
if the new configuration is inconsistent with the joints/constraints that are
present.
When getting, the returned values are pointers to internal data structures,
so the vectors are valid until any changes are made to the rigid body system
structure.

Hmmm. @c{dBodyGetRotation} returns a 4x3 rotation matrix.
}


@funcdef{
void dBodySetMass (dBodyID, const dMass *mass);
void dBodyGetMass (dBodyID, dMass *mass);
}{
Set/get the mass of the body (see the mass functions).
}


@funcdef{
void dBodyAddForce            (dBodyID, dReal fx, dReal fy, dReal fz);
void dBodyAddTorque           (dBodyID, dReal fx, dReal fy, dReal fz);
void dBodyAddRelForce         (dBodyID, dReal fx, dReal fy, dReal fz);
void dBodyAddRelTorque        (dBodyID, dReal fx, dReal fy, dReal fz);
void dBodyAddForceAtPos       (dBodyID, dReal fx, dReal fy, dReal fz,
                                        dReal px, dReal py, dReal pz);
void dBodyAddRelForceAtPos    (dBodyID, dReal fx, dReal fy, dReal fz,
                                        dReal px, dReal py, dReal pz);
void dBodyAddRelForceAtRelPos (dBodyID, dReal fx, dReal fy, dReal fz,
                                        dReal px, dReal py, dReal pz);
}{
Add forces to bodies (absolute or relative coordinates).
The forces are accumulated on to each body, and the accumulators are zeroed
after each time step.
}


@funcdef{
void dBodyGetPointPos    (dBodyID, dReal px, dReal py, dReal pz,
                          dVector3 result);
void dBodyGetPointVel    (dBodyID, dReal px, dReal py, dReal pz,
                          dVector3 result);
void dBodyGetPointRelVel (dBodyID, dReal px, dReal py, dReal pz,
                          dVector3 result);
}{
Utility functions.
}

#############################################################################
@chapter{Joint types and joint functions}

@section{Creating and destroying}

@funcdef{
dJointID dJointCreateBall (dWorldID, dJointGroupID);
dJointID dJointCreateHinge (dWorldID, dJointGroupID);
dJointID dJointCreateSlider (dWorldID, dJointGroupID);
dJointID dJointCreateContact (dWorldID, dJointGroupID,
                              const dContact *);
dJointID dJointCreateHinge2 (dWorldID, dJointGroupID);
dJointID dJointCreateFixed (dWorldID, dJointGroupID);
}{
Create a new joint of a given type.
The joint is initially in "limbo" (i.e. it has no effect on the simulation)
because it does not connect to any bodies.
The joint group ID is 0 to allocate the joint normally.
If it is nonzero the joint is allocated in the given joint group.
The contact joint will be initialized with the given @struct{dContact}
structure.
}


@funcdef{
void dJointDestroy (dJointID);
}{
Destroy a joint, disconnecting it from its attached bodies and removing
it from the world.
However, if the joint is a member of a group then this function has no
effect - to destroy that joint the group must be emptied or destroyed.
}


@funcdef{
dJointGroupID dJointGroupCreate (int max_size);
}{
Create a joint group.
@arg{max_size} is in bytes.
}


@funcdef{
void dJointGroupDestroy (dJointGroupID);
}{
Destroy a joint group. All joints in the joint group will be destroyed.
}


@funcdef{
void dJointGroupEmpty (dJointGroupID);
}{
Empty a joint group. All joints in the joint group will be destroyed,
but the joint group itself will not be destroyed.
}


@section{Miscellaneous}

@funcdef{
void dJointAttach (dJointID, dBodyID body1, dBodyID body2);
}{
Attach the joint to some new bodies.
If the joint is already attached, it will be detached from the old bodies
first.
To attach this joint to only one body, set body1 or body2 to zero - a zero
body refers to the static environment.
Setting both bodies to zero puts the joint into "limbo", i.e. it will
have no effect on the simulation.

Some joints, like hinge-2 need to be attached to two bodies to work.
}


@funcdef{
void dJointSetData (dJointID, void *data);
void *dJointGetData (dJointID);
}{
Get and set the joint's user-data pointer. 
}


@funcdef{
int dAreConnected (dBodyID, dBodyID);
}{
Utility function: return 1 if the two bodies are connected together by
a joint, otherwise return 0.
}



@section{Joint parameter setting functions}

@subsection{Ball and socket}

A ball and socket joint looks like this:

		@center{@picture{pix/ball-and-socket.jpg}}

@funcdef{
void dJointSetBallAnchor (dJointID, dReal x, dReal y, dReal z);
}{
Set the joint anchor point.
}

@funcdef{
void dJointGetBallAnchor (dJointID, dVector3 result);
}{
Get the joint anchor point.
}


@subsection{Hinge}

A hinge joint looks like this:

		@center{@picture{pix/hinge.jpg}}


@funcdef{
void dJointSetHingeAnchor (dJointID, dReal x, dReal y, dReal z);
void dJointSetHingeAxis (dJointID, dReal x, dReal y, dReal z);
}{
Set hinge anchor and axis parameters.
}


@funcdef{
void dJointGetHingeAnchor (dJointID, dVector3 result);
void dJointGetHingeAxis (dJointID, dVector3 result);
}{
Get hinge anchor and axis parameters.
}


@funcdef{
dReal dJointGetHingeAngle (dJointID);
dReal dJointGetHingeAngleRate (dJointID);
}{
Get the hinge angle and the time derivative of this value.
The angle is measured between the two bodies, or between the body and
the static environment.
The angle will be between -pi..pi.

When the hinge anchor or axis is set, the current position of the attached
bodies is examined and that position will be the zero angle.
}



@subsection{Slider}

A slider joint looks like this:

		@center{@picture{pix/slider.jpg}}

@funcdef{
void dJointSetSliderAxis (dJointID, dReal x, dReal y, dReal z);
}{
Set the slider axis parameter.
}


@funcdef{
void dJointGetSliderAxis (dJointID, dVector3 result);
}{
Get the slider axis parameter.
}


@funcdef{
dReal dJointGetSliderPosition (dJointID);
dReal dJointGetSliderPositionRate (dJointID);
}{
Get the slider linear position (i.e. the slider's ``extension'') and the time
derivative of this value.

When the axis is set, the current position of the attached bodies is
examined and that position will be the zero position.
}


@subsection{Hinge-2}

A hinge-2 joint looks like this:

		@center{@picture{pix/hinge2.jpg}}

The hinge-2 joint is the same as two hinges connected in series, with
different hinge axes.
An example, shown in the above picture is the steering wheel of a car,
where one axis allows the wheel to be steered and the other axis allows
the wheel to rotate.

The hinge-2 joint has an anchor point and two hinge axes.
Axis 1 is specified relative to body 1 (this would be the steering axis if
body 1 is the chassis).
Axis 2 is specified relative to body 2 (this would be the wheel axis if
body 2 is the wheel).

Axis 1 can have joint limits and a motor, axis 2 can only have a motor.

Axis 1 can function as a suspension axis, i.e. the constraint can be
compressible along that axis.



@funcdef{
void dJointSetHinge2Anchor (dJointID, dReal x, dReal y, dReal z);
void dJointSetHinge2Axis1 (dJointID, dReal x, dReal y, dReal z);
void dJointSetHinge2Axis2 (dJointID, dReal x, dReal y, dReal z);
}{
Set hinge-2 anchor and axis parameters.
Axis 1 and axis 2 must not lie along the same line.
}


@funcdef{
void dJointGetHinge2Anchor (dJointID, dVector3 result);
void dJointGetHinge2Axis1 (dJointID, dVector3 result);
void dJointGetHinge2Axis2 (dJointID, dVector3 result);
}{
Get hinge-2 anchor and axis parameters.
}


@funcdef{
dReal dJointGetHinge2Angle1 (dJointID);
dReal dJointGetHinge2Angle1Rate (dJointID);
dReal dJointGetHinge2Angle2Rate (dJointID);
}{
Get the hinge-2 angles (around axis 1 and axis 2) and the time derivatives
of these values.

When the anchor or axis is set, the current position of the attached
bodies is examined and that position will be the zero angles.
}


@subsection{Fixed}

The fixed joint maintains a fixed relative position and orientation between
two bodies, or between a body and the static environment.
Using this joint is almost never a good idea in practice, except when
debugging.
If you need two bodies to be glued together it is better to represent that as
a single body.

Currently the fixed joint does not support a non-identity relative rotation
between two bodies, it only supports a relative offset.

@funcdef{
void dJointSetFixed (dJointID);
}{
Call this on the fixed joint after it has been attached to remember the
current desired relative offset between the bodies.
}


@subsection{Contact}

A contact joint looks like this:

		@center{@picture{pix/contact.jpg}}

The contact joint prevents body 1 and body 2 from interpenetrating at the
contact point.
It does this by only allowing the bodies to have an ``outgoing'' velocity
in the direction of the contact normal.
Contact joints typically have a lifetime of one time step.
They are created and deleted in response to collision detection.

Contact joints can simulate friction at the contact by applying special
forces in the two friction directions that are perpendicular to the
normal.

When a contact joint is created, a @c{dContact} structure must be supplied.
This has the following definition:
@code{@[
struct dContact {
  dSurfaceParameters surface;
  dContactGeom geom;
  dVector3 fdir1;
};
@]}
@c{geom} is a substructure that is set by the collision functions.
It is described in the collision section.

@c{fdir1} is a "first friction direction" vector that defines a direction
along which frictional force is applied.
It must be of unit length and perpendicular to the contact normal
(so it is typically tangential to the contact surface).
It should only be defined if the @const{dContactFDir1} flag is set in
@c{surface.mode}.
The "second friction direction" is a vector computed to be perpendicular to
both the contact normal and @c{fdir1}.

@c{surface} is a substructure that is set by the user.
Its members define the properties of the colliding surfaces.
It has the following members:
@list{
@*	@c{int mode} - Contact flags. This must always be defined.
	This is a combination of one or more of the following flags:

	@constdef{dContactMu2}{If not set, use @c{mu} for both friction
		directions. If set, use @c{mu} for friction direction 1,
		use @c{mu2} for friction direction 2.}
	@constdef{dContactFDir1}{If set, take @c{fdir1} as friction direction
		1, otherwise compute friction direction 1 to be perpendicular
		to the contact normal (in which case its resulting orientation
		is not defined).}
	@constdef{dContactBounce}{If set, the contact surface is bouncy,
		in other words the bodies will bounce off each other.
		The exact amount of bouncyness is controlled by the
		@c{bounce} parameter.}
	@constdef{dContactSoftERP}{If set, the error reduction parameter of
		the contact normal can be set with the @c{soft_erp} parameter.
		This is useful to make surfaces soft.}
	@constdef{dContactSoftCFM}{If set, the constraint force mixing
		parameter of the contact normal can be set with the
		@c{soft_cfm} parameter. This is useful to make surfaces soft.}
	@constdef{dContactMotion1}{If set, the contact surface is assumed to
		be moving independently of the motion of the bodies.
		This is kind of like a conveyor belt running over the surface.
		When this flag is set, @c{motion1} defines the surface
		velocity in friction direction 1.}
	@constdef{dContactMotion2}{The same thing as above, but for
		friction direction 2.}
	@constdef{dContactSlip1}{Slip, friction direction 1.
		[this needs more description].}
	@constdef{dContactSlip2}{Slip, friction direction 2.
		[this needs more description].}

@*	@c{dReal mu} : Coulomb friction coefficient.
	This must be in the range 0 to @c{dInfinity}. 0 results in a
	frictionless contact, and @c{dInfinity} results in a contact that
	never slips.
	Note that frictionless contacts are less time consuming to compute
	than ones with friction, and infinite friction contacts can be cheaper
	than contacts with finite friction.
	This must always be defined.

@*	@c{dReal mu2} : Optional Coulomb friction coefficient for friction
		direction 2 (0..@c{dInfinity}). This is only defined if the
		corresponding flag is set is @c{mode}.

@*	@c{dReal bounce} : Restitution parameter (0..1).
	0 means the surfaces are not bouncy at all, 1 is maximum bouncyness.
	This is only defined if the corresponding flag is set is @c{mode}.

@*	@c{dReal bounce_vel} : The minimum incoming velocity necessary for
	bounce (in m/s). Incoming velocities below this will effectively have
	a bounce parameter of 0.
	This is only defined if the corresponding flag is set is @c{mode}.

@*	@c{dReal soft_erp} : Contact normal ``softness'' parameter.
	This is only defined if the corresponding flag is set is @c{mode}.

@*	@c{dReal soft_cfm} : Contact normal ``softness'' parameter.
	This is only defined if the corresponding flag is set is @c{mode}.

@*	@c{dReal motion1,motion2} : Surface velocity in friction directions
	1/2 (m/s).
	This is only defined if the corresponding flag is set is @c{mode}.

@*	@c{dReal slip1,slip2} : First order slip in friction directions 1/2.
	This is only defined if the corresponding flag is set is @c{mode}.
}


@section{General}

The joint geometry parameter setting functions should only be called after
the joint has been attached to bodies, and those bodies have been correctly
positioned, otherwise the joint may not be initialised correctly.
If the joint is not already attached, these functions will do nothing.

For the parameter getting functions, if the system is out of alignment
(i.e. there is some joint error) then the anchor/axis values will be correct
with respect to body 1 only (or body 2 if you specified body 1 as 0 in the
attach function).

The default anchor for all joints is (0,0,0).
The default axis for all joints is (1,0,0).

When an axis is set it will be normalized to unit length.
The adjusted axis is what the axis getting functions will return.


When measuring a joint angle or position, a value of zero corresponds to the
initial position of the bodies relative to each other.

Note that there are no functions to set joint angles or positions (or their
rates) directly, instead you must set the corresponding body positions and
velocities.

Setting joint limits prevents movement of the joint beyond the given
low/high position values.

For joint motors: conceptually, the joint is actually constructed from a
motor and a friction plate [need a diagram here].
The speed of the motor and the maximum torque or force that can be exerted
by the friction plate are both controllable.


@section{Limit and motor parameters}

@funcdef{
void dJointSetHingeParam (dJointID, int parameter, dReal value);
void dJointSetSliderParam (dJointID, int parameter, dReal value);
void dJointSetHinge2Param (dJointID, int parameter, dReal value);
dReal dJointGetHingeParam (dJointID, int parameter);
dReal dJointGetSliderParam (dJointID, int parameter);
dReal dJointGetHinge2Param (dJointID, int parameter);
}{
Set/get limit/motor parameters for each joint type.
The parameter numbers are:

@constdef{dParamLoStop}{Low limit angle/position. Setting this to
	@c{-dInfinity} turns off the low limit.}
@constdef{dParamHiStop}{High limit angle/position. Setting this to
	@c{dInfinity} turns off the high limit.}
@constdef{dParamVel}{Motor velocity (angular or linear).}
@constdef{dParamFMax}{Motor maximum force. Setting this to zero turns off the
	motor.}
@constdef{dParamFudgeFactor}{Fudge factor. Controls powering away from a stop.}
@constdef{dParamBounce}{Limit bounce. Not yet implemented.}
@constdef{dParamStopERP}{Limit softness (ERP).}
@constdef{dParamStopCFM}{Limit softness (CFM).}
@constdef{dParamSuspensionERP}{Suspension error reduction parameter.
	Currently this only works on the hinge-2 joint.}
@constdef{dParamSuspensionCFM}{Suspension constraint force mixing parameter.
	Currently this only works on the hinge-2 joint.}

These parameter names can be followed by a digit >= 2 to indicate the second,
third etc set of parameters, e.g. for the second joint limit, the second
suspension axis etc.

If the low stop < the high stop then the stop functions will do nothing.
For rotational joints, stops outside the range -pi..pi will be ineffective.

The hinge-2 joint has parameters for axis 1 and axis 2 (the steering and wheel
axes).

If a particular parameter is not implemented by a given joint, setting it
will have no effect.

This interface for setting and getting parameters seems to be a bit
inconsistent with the rest of ODE, I may consider modifying it in the
future ... but it works well in practice.
}

#############################################################################
@chapter{Support functions}

@section{Rotation functions}

Rigid body orientations are represented with quaternions.
A quaternion is four numbers [cos(theta/2) sin(theta/2)*u] where
theta is a rotation angle and `u' is a unit length rotation axis.

Every rigid body also has a 3x3 rotation matrix that is derived from
the quaternion.
The rotation matrix and the quaternion always match.

Some information about quaternions:
@list{
@*	q and -q represent the same rotation.
@*	The inverse of a quaternion is [ q[0] -q[1] -q[2] -q[3] ].
}

The following are utility functions for dealing with rotation matrices and
quaternions.

@funcdef{
void dRSetIdentity (dMatrix3 R);
}{
Set @arg{R} to the identity matrix (i.e. no rotation).
}

@funcdef{
void dRFromAxisAndAngle (dMatrix3 R,
                         dReal ax, dReal ay, dReal az, dReal angle);
}{
Compute the rotation matrix @arg{R} as a rotation of @arg{angle} radians
along the axis (@arg{ax},@arg{ay},@arg{az}).
}

@funcdef{
void dRFromEulerAngles (dMatrix3 R,
                        dReal phi, dReal theta, dReal psi);
}{
Compute the rotation matrix @arg{R} from the three Euler rotation angles.
}

@funcdef{
void dRFrom2Axes (dMatrix3 R, dReal ax, dReal ay, dReal az,
                  dReal bx, dReal by, dReal bz);
}{
Compute the rotation matrix @arg{R} from the two vectors `a'
(@arg{ax},@arg{ay},@arg{az}) and `b' (@arg{bx},@arg{by},@arg{bz}).
`a' and `b' are the desired x and y axes of the rotated coordinate system.
If necessary, `a' and `b' will be made unit length, and `b' will be
projected so that it is perpendicular to `a'.
The desired z axis is the cross product of `a' and `b'.
}

@funcdef{
void dQSetIdentity (dQuaternion q);
}{
Set @arg{q} to the identity rotation (i.e. no rotation).
}

@funcdef{
void dQFromAxisAndAngle (dQuaternion q, dReal ax, dReal ay, dReal az,
                         dReal angle);
}{
Compute @arg{q} as a rotation of @arg{angle} radians along the axis
(@arg{ax},@arg{ay},@arg{az}).
}

@funcdef{
void dQMultiply0 (dQuaternion qa,
                  const dQuaternion qb, const dQuaternion qc);
void dQMultiply1 (dQuaternion qa,
                  const dQuaternion qb, const dQuaternion qc);
void dQMultiply2 (dQuaternion qa,
                  const dQuaternion qb, const dQuaternion qc);
void dQMultiply3 (dQuaternion qa,
                  const dQuaternion qb, const dQuaternion qc);
}{
Set @arg{qa} = @arg{qb}*@arg{qc}.
This is that same as @arg{qa} = rotation @arg{qc} followed by rotation
@arg{qa}.
The 0/1/2 versions are analogous to the multiply functions, i.e. 1 uses the
inverse of @arg{qb}, and 2 uses the inverse of @arg{qc}.
Option 3 uses the inverse of both.
}

@funcdef{
void dQtoR (const dQuaternion q, dMatrix3 R);
}{
Convert quaternion @arg{q} to rotation matrix @arg{R}.
}

@funcdef{
void dRtoQ (const dMatrix3 R, dQuaternion q);
}{
Convert rotation matrix @arg{R} to quaternion @arg{q}.
}


@funcdef{
void dWtoDQ (const dVector3 w, const dQuaternion q, dVector4 dq);
}{
Given an existing orientation @arg{q} and an angular velocity vector @arg{w},
return in @arg{dq} the resulting dq/dt.
}

#............................................................................
@section{Mass functions}

The mass parameters of a rigid body are described by a @c{dMass} structure:
@code{@[
typedef struct dMass {
  dReal mass;   // total mass of the rigid body
  dVector4 c;   // center of gravity position in body frame (x,y,z)
  dMatrix3 I;   // 3x3 inertia tensor in body frame, about POR
} dMass;
@]}

The following functions operate on this structure:

@funcdef{
void dMassSetZero (dMass *);
}{
Set all the mass parameters to zero.
}

@funcdef{
void dMassSetParameters (dMass *, dReal themass,
                         dReal cgx, dReal cgy, dReal cgz,
                         dReal I11, dReal I22, dReal I33,
                         dReal I12, dReal I13, dReal I23);
}{
Set the mass parameters to the given values.
@arg{themass} is the mass of the body.
(@arg{cx},@arg{cy},@arg{cz}) is the center of gravity position in the body
frame.
The @c{Ixx} values are the elements of the inertia matrix:
@code{
    [ I11 I12 I13 ]
    [ I12 I22 I23 ]
    [ I13 I23 I33 ]
}
}

@funcdef{
void dMassSetSphere (dMass *, dReal density, dReal radius);
}{
Set the mass parameters to represent a sphere of the given radius and
density, with the center of mass at (0,0,0) relative to the body.
}

@funcdef{
void dMassSetCappedCylinder (dMass *, dReal density, int direction,
                             dReal a, dReal b);
}{
Set the mass parameters to represent a capped cylinder of the given parameters
and density, with the center of mass at (0,0,0) relative to the body.
The radius of the cylinder (and the spherical cap) is @arg{a}.
The length of the cylinder (not counting the spherical cap) is @arg{b}.
The cylinder's long axis is oriented along the body's x, y or z axis according
to the value of @arg{direction} (1=x, 2=y, 3=z).
}

@funcdef{
void dMassSetBox (dMass *, dReal density,
                  dReal lx, dReal ly, dReal lz);
}{
Set the mass parameters to represent a box of the given dimensions
and density, with the center of mass at (0,0,0) relative to the body.
The side lengths of the box along the x, y and z axes are @arg{lx}, @arg{ly}
and @arg{lz}.
}

@funcdef{
void dMassAdjust (dMass *, dReal newmass);
}{
Given mass parameters for some object, adjust them so the total mass is
now @arg{newmass}.
This is useful when using the above functions to set the mass parameters for
certain objects - they take the object density, not the total mass.
}

@funcdef{
void dMassTranslate (dMass *, dReal x, dReal y, dReal z);
}{
Given mass parameters for some object, adjust them to represent the object
displaced by (@arg{x},@arg{y},@arg{z}) relative to the body frame.
}

@funcdef{
void dMassRotate (dMass *, const dMatrix3 R);
}{
Given mass parameters for some object, adjust them to represent the object
rotated by @arg{R} relative to the body frame.
}

#............................................................................
@section{Math functions}

[There are quite a lot of these, but they're not standardized enough to
document yet].

#............................................................................
@section{Error and memory functions}

[Document these later].

#############################################################################
@chapter{Collision functions}

This chapter describes the built-in collision detection system of ODE.
Using ODE's collision detection is optional - an alternative collision
detection system can be used as long as it can supply the right kinds
of information to ODE.

@section{Contact points}

If two bodies touch, or if a body touches a static feature in its environment,
the contact is represented by one or more "contact points".
Each contact point has a corresponding @c{dContactGeom} structure:
@code{@[
struct dContactGeom {
  dVector3 pos;       // contact position
  dVector3 normal;    // normal vector
  dReal depth;        // penetration depth
};
@]}
@arg{pos} records the contact position, in global coordinates.

@arg{depth} is the depth to which the two bodies inter-penetrate each other.
If the depth is zero then the two bodies have a grazing contact, i.e. they
"only just" touch.
However, this is rare - the simulation is not perfectly accurate and will
often step the bodies too far so that the depth is nonzero.

@arg{normal} is a unit length vector that is, generally speaking,
perpendicular to the contact surface.

The convention is that if body 1 is moved along the @arg{normal} vector by a
distance @arg{depth} (or equivalently if body 2 is moved the same distance in
the opposite direction) then the contact depth will be reduced to zero.
This means that the normal vector points "in" to body 1.

In real life, contact between two bodies is a sophisticated thing.
Representing contacts by contact points is only an approximation.
Contact "patches" or "surfaces" might be more physically accurate, but
representing these things in high speed simulation software is a challenge.

Each extra contact point added to the simulation will slow it down some more,
so sometimes we are forced to ignore contact points in the interests of speed.
For example, when two boxes collide many contact points may be needed to
properly represent the geometry of the situation, but we may choose to
keep only the best three. Thus we are piling approximation on top of
approximation.


@section{Geometry objects}

To use ODE's collision detection, geometry objects must be associated with
the rigid bodies.
A geometry object represents a rigid @emph{shape} in space.
Geometry objects are distinct from rigid bodies in that a geometry object
has geometrical properties (size, shape, position and orientation) but no
dynamical properties (such as velocity or mass).

Every geometry object is an instance of a @emph{class}, such as
sphere, plane, or box.
You can define your own classes as well.

Every geometry object has a position vector and a 3*3 rotation matrix.
If a geometry object is associated with a rigid body then its position and
rotation is actually the position and rotation of that body.
The point of reference for the standard classes usually corresponds to their
centers of mass.
This makes them particularly easy to connect to dynamics objects.
If other points of reference are required, composite objects should be used
to encapsulate the primitives.

@subsection{Sphere functions}

@funcdef{
dGeomID dCreateSphere (dSpaceID space, dReal radius);
}{
Create a sphere geometry object of the given @arg{radius}, insert it into the
given @arg{space}, and return its ID.
The point of reference for a sphere is its center.
}


@funcdef{
dReal dGeomSphereGetRadius (dGeomID sphere);
}{
Return the radius of the given sphere.
}


@subsection{Box functions}

@funcdef{
dGeomID dCreateBox (dSpaceID space, dReal lx, dReal ly, dReal lz);
}{
Create a box geometry object of the given x/y/z side lengths
(@arg{lx},@arg{ly},@arg{lz}), insert it into the given @arg{space}, and
return its ID.
The point of reference for a box is its center.
}


@funcdef{
void dGeomBoxGetLengths (dGeomID box, dVector3 result);
}{
Return in @arg{result} the side lengths of the given @arg{box}.
}


@subsection{Plane functions}

@funcdef{
dGeomID dCreatePlane (dSpaceID space,
                      dReal a, dReal b, dReal c, dReal d);
}{
Create a plane geometry object of the given parameters, insert it into the
given @arg{space}, and return its ID.
The plane equation is @center{@m{a*x+b*y+c*z = d}}
The plane's normal vector is @m{(a,b,c)}, and it must have length 1.
Unlike other geometry objects, planes disregard their assigned position and
rotation, i.e. the parameters are always in global coordinates.
In other words it is assumed that the plane is always part of the static
environment and not tied to any movable object.
}


@funcdef{
void dGeomPlaneGetParams (dGeomID plane, dVector4 result);
}{
Return in @arg{result} the parameters of the given @arg{plane}.
}


@subsection{Capped cylinder functions}

@funcdef{
dGeomID dCreateCCylinder (dSpaceID space, dReal a, dReal b, int dir);
void dGeomCCylinderGetParams (dGeomID ccylinder,
                              dReal *a, dReal *b, int *dir);
}{
(not implemented yet.)
}


@subsection{General geometry object functions}

@funcdef{
void dGeomSetData (dGeomID, void *);
void *dGeomGetData (dGeomID);
}{
These functions set and get the user-defined data pointer stored in the
geometry object.
}


@funcdef{
void dGeomSetBody (dGeomID, dBodyID);
dBodyID dGeomGetBody (dGeomID);
}{
These functions set and get the body associated with the geometry object.
Setting the body automatically attaches the position vector and rotation
matrix of the body to the geometry object.
Setting a body ID of zero gives the geometry object its own position and
rotation, independent from any body.
}


@funcdef{
void dGeomSetPosition (dGeomID, dReal x, dReal y, dReal z);
void dGeomSetRotation (dGeomID, const dMatrix3 R);
}{
Set the position vector and rotation matrix of the geometry object.
These functions are analogous to @func{dBodySetPosition()} and
@func{dBodySetRotation()}.
If the geometry object is attached to a body, the body's position / rotation
will also be changed.
}


@funcdef{
const dReal * dGeomGetPosition (dGeomID);
const dReal * dGeomGetRotation (dGeomID);
}{
Return pointers to the geometry object's position vector and rotation matrix.
The returned values are pointers to internal data structures, so the vectors
are valid until any changes are made to the geometry object.
If the geometry object is attached to a body, the body's position / rotation
pointers will be returned, i.e. the result will be identical to calling
@func{dBodyGetPosition()} or @func{dBodyGetRotation()}.
}


@funcdef{
void dGeomDestroy (dGeomID);
}{
Destroy a geometry object, removing it from the space first.
}

@section{Collision detection}

@funcdef{
int dCollide (dGeomID o1, dGeomID o2, int flags,
              dContactGeom *contact, int skip);
}{
Given two geometry objects that potentially touch (@arg{o1} and @arg{o2}),
generate contact information for them.
Internally, this just calls the correct class-specific collision functions
for @arg{o1} and @arg{o2}.

@arg{flags} specifies how contacts should be generated if the objects touch.
Currently the lower 8 bits of @arg{flags} specifies the maximum number of
contact points to generate.
If this number is zero, this function just pretends that it is one - in other
words you can not ask for zero contacts.
All other bits in @arg{flags} must be zero.
In the future the other bits may be used to select other contact generation
strategies.

@arg{contact} must point to an array of contact geometry information that
can hold at least the maximum number of contacts.
@emph{Note:} the elements of the @arg{contact} array do not necessarily have
to be contiguous.
@arg{skip} is the number of bytes between each @struct{dContactGeom}
structure in the @arg{contact} array.
If @arg{skip} is @c{sizeof(dContactGeom)} then @arg{contact} points to a
"normal" (C-style) contact array.
If skip is larger than this, then the @struct{dContactGeom} structures are
embedded in some other larger structures.
It is an error for @arg{skip} to be smaller than @c{sizeof(dContactGeom)}.

If the objects touch, this returns the number of contact points generated
(and updates the @arg{contact} array), otherwise it returns 0 (and the
@arg{contact} array is not touched).
}


@section{User defined classes}

You can define your own geometry classes using the functions in this section.
The standard geometry classes do not have any special access to the internals
of ODE, they use the public functions exactly as you would.

Every geometry class has a unique number (0,1,2, etc...).
A new geometry class (call it `X') must provide the following to ODE:
@numlist{
@*	Functions that will handle collision detection and contact generation
	between X and one or more other classes.
	These functions must be of type @c{dColliderFn}, which is defined as
	@code{@[
typedef int dColliderFn (dGeomID o1, dGeomID o2, int flags,
                         dContactGeom *contact, int skip);
	@]}
	This has exactly the same interface as @func{dCollide()}.
	Each function will handle a specific collision case, where @arg{o1}
	has type X and @arg{o2} has some other known type.

@*	A "selector" function, of type @c{dGetColliderFnFn}, which is
	defined as
	@code{@[
typedef dColliderFn * dGetColliderFnFn (int num);
	@]}
	This function takes a class number (@arg{num}), and returns the
	collider function that can handle colliding X with class @arg{num}.
	It should return 0 if X does not know how to collide with class
	@arg{num}.
	Note that if classes X and Y are to collide, only @emph{one} needs
	to provide a function to collide with the other.

	This function is called infrequently - the return values are cached
	and reused.

@*	A function that will compute the axis aligned bounding box of
	instances of this class.
	This function must be of type @c{dGetAABBFn}, which is defined as
	@code{@[
typedef void dGetAABBFn (dGeomID g, dReal aabb[6]);
	@]}
	This function is given @arg{g}, which has type X, and returns the
	axis-aligned bounding box for @arg{g}.
	The @arg{aabb} array has elements
	@m{(minx, maxx, miny, maxy, minz, maxz)}.

@*	The number of bytes of "class data" that instances of this class
	need. For example a sphere stores its radius in the class data area,
	and a box stores its side lengths there.
}

Here are the functions used to manage custom classes:


@funcdef{
int dCreateGeomClass (const dGeomClass *classptr);
}{
Register a new geometry class, defined by @arg{classptr}.
The number of the new class is returned.
The convention used in ODE is to assign the class number to a global variable
with the name @c{dXxxClass} where Xxx is the class name
(e.g. @c{dSphereClass}).

Here is the definition of the @c{dGeomClass} structure:
@code{@[
struct dGeomClass {
  int bytes;                  // bytes of custom data needed
  dGetColliderFnFn *collider; // collider function
  dGetAABBFn *aabb;           // bounding box function
};
@]}
}


@funcdef{
void * dGeomGetClassData (dGeomID);
}{
Given a geometry object, return a pointer to the class's custom data
(this will be a block of the required number of bytes).
Internal ODE classes may use a slightly faster macro instead.
}


@funcdef{
dGeomID dCreateGeom (int classnum);
}{
Create a geometry object of the given class number.
The custom data block will initially be set to 0.
This object can be added to a space using @func{dSpaceAdd()}.
}


@funcdef{
int dGeomGetClass (dGeomID);
}{
Given a geometry object, this returns its class number.
}


When you implement a new class you will usually write a function that does
the following:
@numlist{
@*	If the class has not yet been created, create it.
	You should be careful to only ever create the class once.
@*	Call @func{dCreateGeom()} to make an instance of the class.
@*	Set up the custom data area.
}
This is what @func{dCreateSphere()} and the other geometry creation
functions do.


@section{Utility functions}


@funcdef{
int dBoxTouchesBox (const dVector3 _p1, const dMatrix3 R1,
                    const dVector3 side1, const dVector3 _p2,
                    const dMatrix3 R2, const dVector3 side2);
}{
Given boxes (@arg{p1},@arg{R1},@arg{side1}) and
(@arg{p2},@arg{R2},@arg{side2}), return 1 if they intersect or 0 if not.
@arg{p} is the center of the box, @arg{R} is the rotation matrix for
the box, and @arg{side} is a vector of x/y/z side lengths.
}


@section{Space}

A space is a container for geometry objects.
It is similar to the rigid body "world", except for collision instead of
dynamics.

The space does high level collision culling, which means that it can
identify which pairs of geometry objects are potentially touching.
You can safely call @func{dCollide()} for only those pairs, instead of
having to call @func{dCollide()} for @emph{every} object-object pair.
This can save a huge amount of time.
Various collision culling algorithms will be available, however only the
first is currently implemented:
@list{
@*	Simple @m{n^2} object intersections.
@*	Oct tree.
@*	Coordinate sorting.
@*	Hash table?
}

Here are the functions used for spaces:

@funcdef{
dSpaceID dSpaceCreate();
}{
Create a space.
}


@funcdef{
void dSpaceDestroy (dSpaceID);
}{
Destroy a space.
When a space is destroyed, all the geometry objects in that space are
automatically destroyed as well.
}


@funcdef{
void dSpaceAdd (dSpaceID, dGeomID);
void dSpaceRemove (dSpaceID, dGeomID);
}{
Add and remove geometry objects to/from the space.
These functions are normally only called by the geometry object
creation/deletion functions.
}


@funcdef{
void dSpaceCollide (dSpaceID space, void *data,
                    dNearCallback *callback);
}{
Call a callback function one or more times, for all potentially intersecting
objects in the space.
The @arg{callback} function is of type @c{dNearCallback}, which is defined as:
@code{@[
typedef void dNearCallback (void *data, dGeomID o1, dGeomID o2);
@]}
The @arg{data} variable is passed from @func{dSpaceCollide()} to the
callback function. Its meaning is user defined.
The @arg{o1} and @arg{o2} arguments are the geometry objects that may be near
each other.
The callback function can call @func{dCollide()} on @arg{o1} and @arg{o2},
perhaps first determining whether to collide them at all based on other
information.
}


@section{Future}

Future interface enhancements:
@list{
@*	Composite objects.
}

#############################################################################
@chapter{How to make good simulations}

[just notes for now]

@section{Integrator accuracy and stability}

@list{
@*	integrator will not give exact solution
@*	what is stabilty
@*	integrator types (exp & imp, order)
@*	tradeoff between accuracy, stability and work
}


@section{Behavior may depend on step size}

@list{
@*	smaller step = more accurate, more stable
@*	10*0.1 not the same as 5*0.2
@*	tweak at final frame rate
}


@section{Making things go faster}

What factors does execution speed depend on?
Each joint removes a number of degrees of freedom (DOFs) from the system.
For example the ball and socket removes three, and the hinge removes five.
For each separate group of bodies connected by joints, where:
@list{
@*	@m{m_1} is the number of joints in the group,
@*	@m{m_2} is the total number of DOFs removed by those joints, and
@*	@m{n} is the number of bodies in the group,
}
then the computing time per step for the group is proportional to:
	@center{@m{k_1 O(m_1) + k_2 O(m_2^3) + k_2 O(n)}}

ODE currently relies on factorization of a ``system'' matrix that has one
row/column for each DOF removed (this is where the @m{O(m_2^3)}
comes from).
In a 10 body chain that uses ball and socket joints, roughly 30-40% of the
time is spent filling in this matrix, and 30-40% of the time is spent
factorizing it.

Thus, to speed up your simulation you might consider:
@list{
@*	Using less joints - often small bodies and their associated joints
	can be replaced by purely kinematic ``fakes'' without harming
	physical realism.
@*	Replacing multiple joints with simpler alternatives.
	This will become easier as more specialized joint types are defined.
@*	Using less contacts.
@*	Preferring frictionless or viscous friction contacts (that remove one
	DOF) over Coulomb friction contacts (that remove three DOFs)
	where possible.
}
In the future ODE will implement techniques that scale better with the number
of joints.


@section{Making things stable}

@list{
@*	stiff springs / stiff forces are bad.
@*	hard constraints are good.
@*	dependence on integration timestep.
@*	Use powered joint, joint limits, built-in springs as much as possible,
	avoid explicit forces.
@*	mass ratios - e.g. a whip
@*	if bodies move faster than is reasonable for the timestep
@*	inetias with long axes
}


@section{Using constraint force mixing (CFM)}

@list{
@*	allow singular configurations
@*	effects: jitter or strange forces due to error amplification,
	LCP solver may go slow
@*	allow compliant joints (this may be unwanted also)
}


@section{Avoiding singularities}

@list{
@*	Singularity occurs when there are more joints than needed to constrain
	the bodies motions.
@*	Multiple (incompatible) joints between bodies, esp joint + contact
	(don't collide objects that are joined together).
@*	increasing CFM
@*	unintentional - box chain on floor, other assemblies
@*	use minimum joints for correct behavior. use correct joints for desired
	behavior
@*	adding global CFM usually helps
}


@section{Other stuff}

@list{
@*	contact jitter when pushed out too far - soln: use softness
@*	keep lengths and masses around 1
@*	LCP solver takes a variable number of iterations (only
	non-deterministic part). if it takes too long, increase global
	CFM, prevent multiple contacts (or similar), and limit high
	ratio of force magnitudes (tree grabbing problem) 
@*	hinge limits outside +/- pi
}

#############################################################################
@chapter{FAQ}

@section{How do I connect a body to the static environment with a joint?}

Use @func{dJointAttach} with arguments @c{(body,0)} or @c{(0,body)}.


@section{Does ODE need or use graphics library X ?}

No. ODE is a computational engine, and is completely independent
of any graphics library.
However the examples that come with ODE use OpenGL,
and most interesting uses of ODE will need some graphics library to
make the simulation visible to the user.
But that's your problem.


@section{Why do my rigid bodies bounce or penetrate on collision?
My restitution is zero!}

Sometimes when rigid bodies collide without restitution, they appear to
interpenetrate slightly and then get pushed apart so that they only just
touch.
The problem gets worse as the time step gets larger.
What is going on?

The contact joint constraint is only applied after the collision is detected.
If a fixed time step is being used, it is likely that the bodies have
already penetrated when this happens.
The error reduction mechanism will push the bodies apart, but this can
take a few time steps (depending on the value of the ERP parameter).

This penetration and pushing apart sometimes makes the bodies look like they
are bouncing, although it is completely independent of whether restitution
is on or not.

Some other simulators have individual rigid bodies take variable sized
timesteps to make sure bodies never penetrate much.
However ODE takes fixed size steps, as automatically choosing a
non-penetrating step size is problematic for an articulated rigid body
simulator (the entire ARB structure must be stepped to account for the
first penetration, which may result in very small steps).

There are three fixes for this problem:
@list{
@*	Take smaller time steps.
@*	Increase ERP to make the problem less visible.
@*	Do your own variable sized time stepping somehow.
}


@section{How can an immovable body be created?}

In other words, how can you create a body that doesn't move, but that
interacts with other bodies?
The answer is to create a geometry object only, without the corresponding
rigid body object.
The geometry object is associated with a rigid body ID of zero.
Then in the contact callback when you detect a collision between two geometry
objects with a nonzero body ID and a zero body ID, you can simply pass those
two IDs to the @func{dJointAttach()} function as normal.
This will create a contact between the rigid body and the static environment.

Don't try to get the same effect by setting a very high mass/inertia on the
``motionless'' body and then resetting it's position/orientation on each
time step.
This can cause unexpected simulation errors.

#############################################################################
@chapter{Known BUGS}

@list{
@*	When assigning a mass to a rigid body, the center of mass must be
	(0,0,0) relative to the body's position.
}

#############################################################################
@chapter{ODE internals}

[only notes for now]

@list{

@*	Internally, all 6x1 spatial velocities and accelerations are split
	into 3x1 position and angular components, which are stored as
	contiguous 4x1 vectors.

@*	Lagrange multiplier velocity based model due to Trinkle and Stewart.
@*	Friction due to Baraff.

@*	Stability over accuracy.

@*	Talk about the different methods possible.
	Say how realtime constraints make the problem much more difficult.

@*	Factorizer.

@*	LCP solver.

@*	Equations of motion.

@*	Friction model and approximations.
}

Why don't I implement a proper friction pyramid or friction cone
(e.g. Baraff's version) ?}
	Because I have to factor non-symmetric (and possibly indefinite)
	matrices, for either static or dynamic friction.
	Speed was considered more important - the current friction
	approximation only needs a symmetric factorization, which is twice
	as fast.


@section{Matrix storage conventions}

Matrix operations like factorization are expensive, so we must store the data
in a way that is most useful to the matrix code.
I want to do 4-way SIMD optimizations later, so the format is this: store
the matrix by rows, and each row is rounded up to a multiple of 4 elements.
The extra "padding" elements at the end of each row/column must be set
to 0.
This is called the "standard format".
Hopefully this decision will remain good in the future, as more and
more processors have 4-way SIMD (especially for fast 3D graphics).

The exception: matrices that have only one column or row (vectors), are always
stored as consecutive elements in standard row format, i.e. there is no
interior padding, only padding at the end.

Thus: all 3x1 floating point vectors are stored as 4x1 vectors: (x,x,x,0).


@section{Internals FAQ}

@subsection{Why to some structures have a @c{dx} prefix and some have a
@c{d} prefix?}

The @c{dx} prefix is used for internal structures that should never be
visible externally.
The @c{d} prefix is used for structures that are part of the public
interface.
