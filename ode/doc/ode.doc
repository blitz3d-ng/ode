
@title{Open Dynamics Engine v0.015 User Guide}
@subtitle{Russell Smith, @date{}}
@author{Russell Smith, @date{}}

@center{This document is Copyright &copy 2001 Russell Smith.}
@center{This is a DRAFT document}

@chapter{Contents @nonumber @nocontents}
@contents

#############################################################################
@chapter{Introduction}

The Open Dynamics Engine (ODE) is a free software library for the simulation
of Rigid Body Dynamics.
If this does not make much sense to you, check out
@link{http://www.q12.org/ode/slides/slides.html}{What is a Physics SDK?}.
ODE is being developed by @link{http://www.q12.org}{Russell Smith}.

The is the user guide for the second prototype release of ODE (version 0.015).
This release is just for testing the core algorithms and evolving the API.
The API is becoming more solid, though expect a few (hopefully minor) changes
in the future.


@section{Current features}

The current features are:
@list{
@*	ODE is best for simulating @emph{articulated} rigid body structures,
	such as ground vehicles and legged creatures.
	An articulated structure is when rigid bodies are created in a
	dynamics-world and connected together with joints of various kinds.
@*	ODE is also good for simulating objects in changing environments,
	such as disordered virtual reality environments.
	The user has complete freedom to change the structure of the system,
	even while the simulation is running.
@*	ODE uses a highly stable integrator, which means that the simulation
	errors should not get out of control. This means that a simulated
	system should not "explode" for no reason.

@*	The equations of motion are derived from a Lagrange multiplier
	velocity based model due to Trinkle/Stewart and Anitescu/Potra.
@*	The friction model and LCP solver come from Baraff's work.

@*	A first order integrator is being used. It's fast, but not accurate
	enough for quantitative engineering yet. Higher order integrators
	will come later.
@*	ODE has @emph{hard} contacts. This means that a non-penetration
	constraint is used when two bodies collide. The alternative is to
	model contact with springs and dampers, but this is difficult and
	error-prone.
@*	ODE implements a fast approximation to the Coloumb friction model.
@*	ODE has built-in collision detection. However you can ignore it and
	do your own collision detection if desired.
	The current collision primitives are sphere, box and plane
	(but box-box collision is not yet fully working).
	More collision objects will come later, as well as quick
	identification of potentially intersecting pairs.
@*	Joints types: ball-and-socket, hinge, slider (prismatic).
@*	Platform specific optimizations.
@*	Has a native C interface, even though it is written in C++.
@*	Has a C++ interface built on top of the C one.
@*	Unit tests.
@*	Other stuff I forgot to mention...
}

Some important things that are missing right now:
@list{
@*	Box-box collision.
}

@section{New in the 0.015 release}

@list{
@* Collision framework nearing stability.
@* Collision: all interactions of sphere, box, plane, except box-box is not yet
   fully implemented.
@* 2D & 3D friction.
}


@section{Future features}

@subsection{Plan for 0.02 release}

@list{
@* Update documentation.
@* Rationalize collision framework.
@* Box-box collision.
@* Improve the approximation to Coloumb friction.
@* Full cross platform build system and automatic configuration.
@* Argument checking for all functions (especially joint-typed functions).
}

@subsection{Plan for 0.03 release}

@list{
@* Update documentation.
@* High level functions that create dynamics and collision objects together.
@* Special vehicle joints
@* Powered hinge, prism joint, ball-n-socket (plus dry friction in joints).
@* Joint limits.
@* More contact modes: restitution, moving surface, tyre slip.
@* Implicit spring framework.
@* Optimize LCP solver even more.
@* More collision primitives: capped cylinder, slab, composite objects.
@* Some internals documentation.
@* Automatic code optimization process.
@* Collision space: quick identification of potentially intersecting pairs.
}

@subsection{Plan for 0.04 release}

@list{
@* Update documentation.
@* Static (still) groups not simulated.
@* SSE and 3DNow optimizations.
@* More collision primitives: cylinder, cone?
@* Higher order integrators for higher accuracy. Also force callback functions.
@* More internals documentation.
}

@subsection{Other stuff for later releases}

@list{
@* Simulation tutorial, full documentation of internals and methods.
@* Collision: polyhedral objects, triangle soup.
@* Add reduced coordinate methods for a major speed improvement on
   tree-structured systems.
@* Thread safe.
}


@section{ODE's license}

ODE is Copyright &copy; 2001 Russell Smith.

This library is free software; you can redistribute it and/or
modify it under the terms of the @link{http://www.opensource.org/licenses/lgpl-license.html}{GNU Lesser General Public License}
as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.


@section{Call for volunteers}

Think you can help? Please @link{http://www.q12.org}{write to me}.

#############################################################################
@chapter{Concepts}

@section{Background}

[Here is where I will write some background information about rigid body
dynamics and simulation.
But in the meantime, please refer to Baraff's excellent
@link{http://www.cs.cmu.edu/~baraff/sigcourse/index.html}{SIGGRAPH tutorial}].


@section{Rigid bodies}

A rigid body has various properties from the point of view of the simulation.
Some properties change over time:
@list{
@*	Position vector (x,y,z) of a point of reference.
	Currently the point of reference is the center of mass.
@*	Linear velocity vector (vx,vy,vz)
@*	Orientation, represented by a quaternion (qs,qx,qy,qz) or a 3x3
	rotation matrix.
@*	Angular velocity vector (wx,wy,wz)

}
Other properties are usually constant over time:
@list{
@*	Mass.
@*	Position of the center of mass with respect to the point of reference.
	In the current implementation the center of mass and the point of
	reference must coincide.
@*	Inertia matrix. This is a 3x3 matrix that describes how the body's
	mass is distributed around the center of mass.
}
Note that the @emph{shape} of a rigid body is not a dynamical properties
(except insofar as it influences the various mass properties).
It is only @emph{collision detection} that cares about the detailed shape of
the body.


@subsection{Force accumulators}

Between each integrator step the user can call functions to apply forces
to the rigid body.
These forces are added to "force accumulators" in the rigid body object.
When the next integrator step happens, the sum of all the applied forces
will be used.
The forces accumulators are set to zero after each integrator step.


@section{Joints}

A joint constrains two bodies so that they can only have certain positions
relative to each other.
For example, a ball and socket joint constraints the "ball" of one body to
be in the same location as the "socket" of another body.

[Describe the different kinds of joints here, and their parameters].

The functions to set joint parameters all take global coordinates.
An example is the position of the ball-and-socket point for a ball-and-socket
joint.
A consequence of this is that the rigid bodies that a joint connects must be
positioned correctly @emph{before} the joint is attached.


@section{Joint groups}

A joint group is a special container that holds joints in a world.
Joints can be added to a group, and then when those joints are no
longer needed the entire group of joints can be very quickly destroyed
with one function call.
However, individual joints in a group can not be destroyed before the entire
group is emptied.

This is most useful with contact joints, which are added and remove from
the world in groups every time step.


@section{Joint error}

When a joint attaches two bodies, those bodies are required to have certain
positions relative to each other [see the above description of what a joint
actually is].
However, it is possible for the bodies to be in positions where the joint
constraint is not met. This "joint error" can happen in two ways:
@numlist{
@*	If the user sets the position/orientation of one body without correctly
	setting the position/orientation of the other body.
@*	During the simulation errors can creep in that result in the bodies
	pulling away from their required positions.
}
There is a mechanism to reduce joint error.
During each simulation step a special force is applied to bring the bodies
back into correct alignment.
This force is controlled by the error reduction parameter (erp), which has
a value between 0 and 1.
The erp parameter specifies what proportion of the joint error will be
fixed during the next simulation step.
If erp=0 then no correcting force is applied and the bodies will eventually
drift apart as the simulation proceeds.
If erp=1 then the simulation will attempt to fix all joint error during the
next time step.
However, setting erp=1 is not recommended, as the joint error will not be
completely fixed due to various internal approximations.
A value of erp=0.2 to 0.5 is recommended (0.2 is the default).


@section{Collision handling}

[There is a lot that needs to be written about collision handling.]

Collisions between bodies or between bodies and the static environment are
handled as follows:
@numlist{
@*	Before each simulation step, the user calls collision detection
	functions to determine what is touching what.
	The built-in collision functions can be used, or any others.
@*	For each contact point between two bodies or between a body and the
	static environment, a special contact joint is created.
	The contact joint is given the position of the contact point, a normal
	vector and a penetration depth.
@*	The contact points are put in a joint "group", which allows them to be
	added to and removed from the system very quickly.
	The simulation will speed goes down as the number of contacts goes up,
	so various strategies can be used to limit the number of contact
	points.
@*	A simulation step is taken.
@*	All contact joints are removed from the system.
}


@section{Typical simulation code}

A typical simulation will proceed like this:
@numlist{
@*	Create a dynamics world.
@*	Create bodies in the dynamics world.
@*	Set the state (position etc) of all bodies.
@*	Create joints in the dynamics world.
@*	Attach the joints to the bodies.
@*	Set the parameters of all joints.
@*	Create a collision world and collision geometry objects, as
	necessary.
@*	Create a joint group to hold the contact joints.
@*	Loop: @numlist{
	@*	Apply forces to the bodies as necessary.
	@*	Adjust the joint parameters as necessary.
	@*	Call collision detection.
	@*	Create a contact joint for every collision point, and put it
		in the contact joint group.
	@*	Take a simulation step.
	@*	Remove all joints in the contact joint group.
	}
@*	Destroy the dynamics and collision worlds.
}


@section{Physics model}

[Discuss the various methods and approximations that are used.]


#############################################################################
@chapter{Data types and conventions}

@section{The basic data types}

The ODE library can be build to use either single or double precision floating
point numbers.
Single precision is faster and uses less memory, but the simulation will
have more numerical error that can result in visible problems.
You will get less accuracy and stability with single precision.

[must describe what factors influence accuracy and stability].

The floating point data type is @c{dReal}.
Other commonly used types are @c{dVector3}, @c{dVector4}, @c{dMatrix3},
@c{dMatrix4}, @c{dQuaternion}.


@section{Objects and IDs}

There are various kinds of object that can be created:
@list{
@*	dWorld - a dynamics world.
@*	dSpace - a collision space.
@*	dBody - a rigid body.
@*	dGeom - geometry (for collision).
@*	dJoint - a joint
@*	dJointGroup - a group of joints.
}
Functions that deal with these objects take and return object IDs.
The object ID types are @c{dWorldID}, @c{dBodyID}, etc.


@section{Argument conventions}

All 3-vectors (x,y,z) supplied to ``set'' functions are given as individual
x,y,z arguments.

All 3-vector result arguments to get() function are pointers to arrays of
@c{dReal}.

Larger vectors are always supplied and returned as pointers.

All coordinates are in the global frame except where otherwise specified.


@section{C versus C++}

The ODE library is written in C++, but its public interface is made of simple
C functions, not classes. Why is this?
@list{
@*	It helps simplicity.
@*	It prevents C++ mangling and runtime-support problems across multiple
	compilers.
@*	The user doesn't have to be familiar with C++ quirks to use ODE.
}

#############################################################################
@chapter{World}

The world object is a container for rigid bodies and joints.

@funcdef{
dWorldID dWorldCreate();
}{
Create a new, empty world and return its ID number.
}


@funcdef{
void dWorldDestroy (dWorldID);
}{
Destroy a world and everything in it.
}


@funcdef{
void dWorldSetGravity (dWorldID, dReal x, dReal y, dReal z);
void dWorldGetGravity (dWorldID, dVector3 gravity);
}{
Set and get the world's global gravity vector. The units are m/s/s, so Earth's
gravity vector would be (0,0,-9.81), assuming that +z is up.
The default is no gravity, i.e. (0,0,0).
}


@funcdef{
void dWorldStep (dWorldID, dReal stepsize);
}{
Step the world.
}


#############################################################################
@chapter{Rigid body functions}

@funcdef{
dBodyID dBodyCreate (dWorldID);
}{
Create a body in the given world with default mass parameters at
position (0,0,0).
Return its ID.
}


@funcdef{
void dBodyDestroy (dBodyID);
}{
Destroy a body.
All joints that are attached to this body will be put into limbo
(i.e. unattached and not affecting the simulation, but they will NOT be
deleted).
}


@funcdef{
void  dBodySetData (dBodyID, void *data);
void *dBodyGetData (dBodyID);
}{
Get and set the body's user-data pointer.
}


@funcdef{
void dBodySetPosition   (dBodyID, dReal x, dReal y, dReal z);
void dBodySetRotation   (dBodyID, const dMatrix3 R);
void dBodySetQuaternion (dBodyID, const dQuaternion q);
void dBodySetLinearVel  (dBodyID, dReal x, dReal y, dReal z);
void dBodySetAngularVel (dBodyID, dReal x, dReal y, dReal z);
const dReal * dBodyGetPosition   (dBodyID);
const dReal * dBodyGetRotation   (dBodyID);
const dReal * dBodyGetQuaternion (dBodyID);
const dReal * dBodyGetLinearVel  (dBodyID);
const dReal * dBodyGetAngularVel (dBodyID);
}{
These functions set and get the position, rotation, linear and angular
velocity of the body.
After setting a group of bodies, the outcome of the simulation is undefined
if the new configuration is inconsistent with the joints/constraints that are
present.
When getting, the returned values are pointers to internal data structures,
so the vectors are valid until any changes are made to the rigid body system
structure.

Hmmm. @c{dBodyGetRotation} returns a 4x3 rotation matrix.
}


@funcdef{
void dBodySetMass (dBodyID, const dMass *mass);
void dBodyGetMass (dBodyID, dMass *mass);
}{
Set/get the mass of the body (see the mass functions).
}


@funcdef{
void dBodyAddForce            (dBodyID, dReal fx, dReal fy, dReal fz);
void dBodyAddTorque           (dBodyID, dReal fx, dReal fy, dReal fz);
void dBodyAddRelForce         (dBodyID, dReal fx, dReal fy, dReal fz);
void dBodyAddRelTorque        (dBodyID, dReal fx, dReal fy, dReal fz);
void dBodyAddForceAtPos       (dBodyID, dReal fx, dReal fy, dReal fz,
                                        dReal px, dReal py, dReal pz);
void dBodyAddRelForceAtPos    (dBodyID, dReal fx, dReal fy, dReal fz,
                                        dReal px, dReal py, dReal pz);
void dBodyAddRelForceAtRelPos (dBodyID, dReal fx, dReal fy, dReal fz,
                                        dReal px, dReal py, dReal pz);
}{
Add forces to bodies (absolute or relative coordinates).
The forces are accumulated on to each body, and the accumulators are zeroed
after each time step.
}


@funcdef{
void dBodyGetPointPos    (dBodyID, dReal px, dReal py, dReal pz,
                          dVector3 result);
void dBodyGetPointVel    (dBodyID, dReal px, dReal py, dReal pz,
                          dVector3 result);
void dBodyGetPointRelVel (dBodyID, dReal px, dReal py, dReal pz,
                          dVector3 result);
}{
Utility functions.
}

#############################################################################
@chapter{Joint functions}

@funcdef{
dJointID dJointCreateBall (dWorldID, dJointGroupID);
dJointID dJointCreateHinge (dWorldID, dJointGroupID);
dJointID dJointCreateSlider (dWorldID, dJointGroupID);
dJointID dJointCreateContact (dWorldID, dJointGroupID, const dContact *);
}{
Create a new joint of a given type.
The joint is initially in "limbo" (i.e. it has no effect on the simulation)
because it does not connect any bodies.
The joint group ID is 0 to allocate the joint normally.
If it is nonzero the joint is allocated in a joint group.
The contact joint will be initialized with the given @struct{dContact}
structure.
}


@funcdef{
void dJointDestroy (dJointID);
}{
Destroy a joint, disconnecting it from its attached bodies and removing
it from the world.
However, if the joint is a member of a group then this function has no
effect - to destroy that joint the group must be emptied or destroyed.
}


@funcdef{
dJointGroupID dJointGroupCreate (int max_size);
}{
Create a joint group.
@arg{max_size} is in bytes.
}


@funcdef{
void dJointGroupDestroy (dJointGroupID);
}{
Destroy a joint group. All joints in the joint group will be destroyed.
}


@funcdef{
void dJointGroupEmpty (dJointGroupID);
}{
Empty a joint group. All joints in the joint group will be destroyed,
but the joint group itself will not be destroyed.
}


@funcdef{
void dJointAttach (dJointID, dBodyID body1, dBodyID body2);
}{
Attach the joint to some new bodies.
If the joint is already attached, it will be detached from the old bodies
first.
To attach this joint to only one body, set body1 or body2 to zero - a zero
body means the static environment.
Setting both bodies to zero puts the joint into "limbo", i.e. it will
have no effect on the simulation.
}


@funcdef{
void dJointSetAnchor (dJointID, dReal x, dReal y, dReal z);
void dJointSetAxis (dJointID, dReal x, dReal y, dReal z);
}{
Set joint parameters.
The anchor and axis must be set after the joint has been attached to bodies
and those bodies have been correctly positioned.
If the joint is not attached, this will do nothing.
The axis that is set will be normalized to unit length, this is what
@c{dJointGetAxis()} will return.
}


@funcdef{
void dJointGetAnchor (dJointID, dVector3 result);
void dJointGetAxis (dJointID, dVector3 result);
}{
Get joint parameters.
If the system is out of alignment (i.e. there is some joint error) then
anchor/axis values will be correct with respect to body 1 only (or body2 if
you specified body 1 as 0).
}


@funcdef{
dReal dJointGetHingePosition (dJointID);
dReal dJointGetHingeVelocity (dJointID);
dReal dJointGetSliderPosition (dJointID);
dReal dJointGetSliderVelocity (dJointID);
}{
Returns the current position and velocity of the given hinge or slider joint.

The position of a hinge joint is the angle between the two bodies
(or between the body and the static environment) measured around the hinge
axis. The initial position of the bodies will correspond to an angle of zero.

The position of a slider joint is the extension of the slider.
The initial position of the bodies will correspond to a position of zero.

The returned velocity values are the rates of change of the position values.

There are no functions to set joint positions and velocities directly,
instead you must set the corresponding body positions and velocities.
}


@funcdef{
void dJointSetHingeLimits (dJointID, dReal low, dReal high);
void dJointSetSliderLimits (dJointID, dReal low, dReal high);
void dJointGetHingeLimits (dJointID, dReal *low, dReal *high);
void dJointGetSliderLimits (dJointID, dReal *low, dReal *high);
}{
Set/get joint limits.
Setting joint limits prevents movement of the joint beyond the given
low/high position values.
It is acceptable to set low to @c{-dInfinity} or high to @c{dInfinity}.
}


@funcdef{
void dJointSetHingeMotor (dJointID, dReal speed, dReal torque);
void dJointSetSliderMotor (dJointID, dReal speed, dReal force);
void dJointGetHingeMotor (dJointID, dReal *speed, dReal *torque);
void dJointGetSliderMotor (dJointID, dReal *speed, dReal *force);
}{
Set/get joint motor parameters.
Conceptually, the hinge and slider joints are actually constructed from a
motor and a friction plate [need a diagram here].
This sets/gets the speed of the motor and the maximum torque or force that
can be exerted by the friction plate.
}


@funcdef{
int dAreConnected (dBodyID, dBodyID);
}{
Utility function: return 1 if the two bodies are connected together by
a joint, otherwise return 0.
}

#############################################################################
@chapter{Rotation functions}

Rigid body orientations are represented with quaternions.
A quaternion is four numbers [cos(theta/2) sin(theta/2)*u] where
theta is a rotation angle and `u' is a unit length rotation axis.

Every rigid body also has a 3x3 rotation matrix that is derived from
the quaternion.
The rotation matrix and the quaternion always match.

Some information about quaternions:
@list{
@*	q and -q represent the same rotation.
@*	The inverse of a quaternion is [ q[0] -q[1] -q[2] -q[3] ].
}

The following are utility functions for dealing with rotation matrices and
quaternions.

@funcdef{
void dRSetIdentity (dMatrix3 R);
}{
Set @arg{R} to the identity matrix (i.e. no rotation).
}

@funcdef{
void dRFromAxisAndAngle (dMatrix3 R, dReal ax, dReal ay, dReal az,
                         dReal angle);
}{
Compute the rotation matrix @arg{R} as a rotation of @arg{angle} radians
along the axis (@arg{ax},@arg{ay},@arg{az}).
}

@funcdef{
void dRFromEulerAngles (dMatrix3 R, dReal phi, dReal theta, dReal psi);
}{
Compute the rotation matrix @arg{R} from the three Euler rotation angles.
}

@funcdef{
void dRFrom2Axes (dMatrix3 R, dReal ax, dReal ay, dReal az,
                  dReal bx, dReal by, dReal bz);
}{
Compute the rotation matrix @arg{R} from the two vectors `a'
(@arg{ax},@arg{ay},@arg{az}) and `b' (@arg{bx},@arg{by},@arg{bz}).
`a' and `b' are the desired x and y axes of the rotated coordinate system.
If necessary, `a' and `b' will be made unit length, and `b' will be
projected so that it is perpendicular to `a'.
The desired z axis is the cross product of `a' and `b'.
}

@funcdef{
void dQSetIdentity (dQuaternion q);
}{
Set @arg{q} to the identity rotation (i.e. no rotation).
}

@funcdef{
void dQFromAxisAndAngle (dQuaternion q, dReal ax, dReal ay, dReal az,
                         dReal angle);
}{
Compute @arg{q} as a rotation of @arg{angle} radians along the axis
(@arg{ax},@arg{ay},@arg{az}).
}

@funcdef{
void dQMultiply0 (dQuaternion qa, const dQuaternion qb, const dQuaternion qc);
void dQMultiply1 (dQuaternion qa, const dQuaternion qb, const dQuaternion qc);
void dQMultiply2 (dQuaternion qa, const dQuaternion qb, const dQuaternion qc);
void dQMultiply3 (dQuaternion qa, const dQuaternion qb, const dQuaternion qc);
}{
Set @arg{qa} = @arg{qb}*@arg{qc}.
This is that same as @arg{qa} = rotation @arg{qc} followed by rotation
@arg{qa}.
The 0/1/2 versions are analogous to the multiply functions, i.e. 1 uses the
inverse of @arg{qb}, and 2 uses the inverse of @arg{qc}.
Option 3 uses the inverse of both.
}

@funcdef{
void dQtoR (const dQuaternion q, dMatrix3 R);
}{
Convert quaternion @arg{q} to rotation matrix @arg{R}.
}

@funcdef{
void dRtoQ (const dMatrix3 R, dQuaternion q);
}{
Convert rotation matrix @arg{R} to quaternion @arg{q}.
}


@funcdef{
void dWtoDQ (const dVector3 w, const dQuaternion q, dVector4 dq);
}{
Given an existing orientation @arg{q} and an angular velocity vector @arg{w},
return in @arg{dq} the resulting dq/dt.
}

#############################################################################
@chapter{Mass functions}

The mass parameters of a rigid body are described by a @c{dMass} structure:
@code{@[
typedef struct dMass {
  dReal mass;   // total mass of the rigid body
  dVector4 c;   // center of gravity position in body frame (x,y,z)
  dMatrix3 I;   // 3x3 inertia tensor in body frame, about POR
} dMass;
@]}

The following functions operate on this structure:

@funcdef{
void dMassSetZero (dMass *);
}{
Set all the mass parameters to zero.
}

@funcdef{
void dMassSetParameters (dMass *, dReal themass,
                         dReal cgx, dReal cgy, dReal cgz,
                         dReal I11, dReal I22, dReal I33,
                         dReal I12, dReal I13, dReal I23);
}{
Set the mass parameters to the given values.
@arg{themass} is the mass of the body.
(@arg{cx},@arg{cy},@arg{cz}) is the center of gravity position in the body
frame.
The @c{Ixx} values are the elements of the inertia matrix:
@code{
    [ I11 I12 I13 ]
    [ I12 I22 I23 ]
    [ I13 I23 I33 ]
}
}

@funcdef{
void dMassSetSphere (dMass *, dReal density, dReal radius);
}{
Set the mass parameters to represent a sphere of the given radius and
density, with the center of mass at (0,0,0) relative to the body.
}

@funcdef{
void dMassSetCappedCylinder (dMass *, dReal density, int direction,
                             dReal a, dReal b);
}{
Set the mass parameters to represent a capped cylinder of the given parameters
and density, with the center of mass at (0,0,0) relative to the body.
The radius of the cylinder (and the spherical cap) is @arg{a}.
The length of the cylinder (not counting the spherical cap) is @arg{b}.
The cylinder's long axis is oriented along the body's x, y or z axis according
to the value of @arg{direction} (1=x, 2=y, 3=z).
}

@funcdef{
void dMassSetBox (dMass *, dReal density,
                  dReal lx, dReal ly, dReal lz);
}{
Set the mass parameters to represent a box of the given dimensions
and density, with the center of mass at (0,0,0) relative to the body.
The side lengths of the box along the x, y and z axes are @arg{lx}, @arg{ly}
and @arg{lz}.
}

@funcdef{
void dMassAdjust (dMass *, dReal newmass);
}{
Given mass parameters for some object, adjust them so the total mass is
now @arg{newmass}.
This is useful when using the above functions to set the mass parameters for
certain objects - they take the object density, not the total mass.
}

@funcdef{
void dMassTranslate (dMass *, dReal x, dReal y, dReal z);
}{
Given mass parameters for some object, adjust them to represent the object
displaced by (@arg{x},@arg{y},@arg{z}) relative to the body frame.
}

@funcdef{
void dMassRotate (dMass *, const dMatrix3 R);
}{
Given mass parameters for some object, adjust them to represent the object
rotated by @arg{R} relative to the body frame.
}

#############################################################################
@chapter{Math functions}

[There are quite a lot of these, but they're not standardized enough to
document yet].

#############################################################################
@chapter{Error and memory functions}

[Document these later].

#############################################################################
@chapter{Collision functions}

This chapter describes the built-in collision detection system of ODE.
Using ODE's collision detection is optional - an alternative collision
detection system can be used as long as it can supply the right kinds
of information to ODE.

@section{Contact points}

If two bodies touch, or if a body touches a static feature in its environment,
the contact is represented by one or more "contact points".
Each contact point has a corresponding @c{dContactGeom} structure:
@code{@[
struct dContactGeom {
  dVector3 pos;       // contact position
  dVector3 normal;    // normal vector
  dReal depth;        // penetration depth
};
@]}
@arg{pos} records the contact position, in global coordinates.

@arg{depth} is the depth to which the two bodies interpenetrate each other.
If the depth is zero then the two bodies have a grazing contact, i.e. they
"only just" touch.
However, this is rare - the simulation is not perfectly accurate and will
often step the bodies too far so that the depth is nonzero.

@arg{normal} is a unit length vector that is, generally speaking,
perpendicular to the contact surface.

The convention is that if body 1 is moved along the @arg{normal} vector by a
distance @arg{depth} (or equivalently if body 2 is moved the same distance in
the opposite direction) then the contact depth will be reduced to zero.
This means that the normal vector points "in" to body 1.

In real life, contact between two bodies is a sophisticated thing.
Representing contacts by contact points is only an approximation.
Contact "patches" or "surfaces" might be more physically accurate, but
representing these things in high speed simulation software is a challenge.

Each extra contact point added to the simulation will slow it down some more,
so sometimes we are forced to ignore contact points in the interests of speed.
For example, when two boxes collide many contact points may be needed to
properly represent the geometry of the situation, but we may choose to
keep only the "best" three. Thus we are piling approximation on top of
approximation.


@section{Geometry objects}

To use ODE's collision detection, geometry objects must be associated with
the rigid bodies.
A geometry object represents a rigid @emph{shape} in space.
Geometry objects are distinct from rigid bodies in that a geometry object
has geometrical properties (size, shape, position and orientation) but no
dynamical properties (such as velocity or mass).

Every geometry object is an instance of a @emph{class}.
The built in classes are currently: sphere, plane, and box
(more will be added later).
You can define your own classes as well.

Every geometry object has a position vector and a 3*3 rotation matrix.
If a geometry object is associated with a rigid body then its position and
rotation is actually the position and rotation of that body.
The point of reference for the standard classes usually corresponds to their
center of mass.
This makes them particularly easy to connect to dynamics objects.
If other points of reference are required, composite objects should be used
to encapsulate the primitives (note that composite objects are not implemented
just yet).

@subsection{Sphere functions}

@funcdef{
dGeomID dCreateSphere (dSpaceID space, dReal radius);
}{
Create a sphere geometry object of the given @arg{radius}, insert it into the
given @arg{space}, and return its ID.
The point of reference for a sphere is its center.
}


@funcdef{
dReal dGeomSphereGetRadius (dGeomID sphere);
}{
Return the radius of the given sphere.
}


@subsection{Box functions}

@funcdef{
dGeomID dCreateBox (dSpaceID space, dReal lx, dReal ly, dReal lz);
}{
Create a box geometry object of the given x/y/z side lengths
(@arg{lx},@arg{ly},@arg{lz}) insert it into the given @arg{space}, and
return its ID.
The point of reference for a box is its center.
}


@funcdef{
void dGeomBoxGetLengths (dGeomID box, dVector3 result);
}{
Return in @arg{result} the side lengths of the given @arg{box}.
}


@subsection{Plane functions}

@funcdef{
dGeomID dCreatePlane (dSpaceID space, dReal a, dReal b, dReal c, dReal d);
}{
Create a plane geometry object of the given parameters, insert it into the
given @arg{space}, and return its ID.
The plane equation is @center{@m{a*x+b*y+c*z = d}}
The plane's normal vector is @m{(a,b,c)}, and it must have length 1.
Unlike other geometry objects, planes disregard their assigned position and
rotation, i.e. the parameters are always in global coordinates.
In other words it is assumed that the plane is always part of the static
environment and not tied to any movable object.
}


@funcdef{
void dGeomPlaneGetParams (dGeomID plane, dVector4 result);
}{
Return in @arg{result} the parameters of the given @arg{plane}.
}


@subsection{Capped cylinder functions}

@funcdef{
dGeomID dCreateCCylinder (dSpaceID space, dReal a, dReal b, int dir);
void dGeomCCylinderGetParams (dGeomID, dReal *a, dReal *b, int *dir);
}{
(not implemented yet.)
}


@subsection{General geometry object functions}

@funcdef{
void dGeomSetData (dGeomID, void *);
void *dGeomGetData (dGeomID);
}{
These functions set and get the user-defined data pointer stored in the
geometry object.
}


@funcdef{
void dGeomSetBody (dGeomID, dBodyID);
dBodyID dGeomGetBody (dGeomID);
}{
These functions set and get the body associated with the geometry object.
Setting the body automatically attaches the position vector and rotation
matrix of the body to the geometry object.
Setting a body ID of zero gives the geometry object its own position and
rotation, independent from any body.
}


@funcdef{
void dGeomSetPosition (dGeomID, dReal x, dReal y, dReal z);
void dGeomSetRotation (dGeomID, const dMatrix3 R);
}{
Set the position vector and rotation matrix of the geometry object.
These functions are analogous to @func{dBodySetPosition()} and
@func{dBodySetRotation()}.
If the geometry object is attached to a body, the body's position / rotation
will also be changed.
}


@funcdef{
const dReal * dGeomGetPosition (dGeomID);
const dReal * dGeomGetRotation (dGeomID);
}{
Return pointers to the geometry object's position vector and rotation matrix.
The returned values are pointers to internal data structures, so the vectors
are valid until any changes are made to the geometry object.
If the geometry object is attached to a body, the body's position / rotation
pointers will be returned, i.e. the result will be identical to calling
@func{dBodyGetPosition()} or @func{dBodyGetRotation()}.
}


@funcdef{
void dDestroyGeom (dGeomID);
}{
Destroy a geometry object, removing it from the space first.
}

@section{Collision detection}

@funcdef{
int dCollide (dGeomID o1, dGeomID o2, int flags,
              dContactGeom *contact, int skip);
}{
Given two geometry objects that potentially touch (@arg{o1} and @arg{o2}),
generate contact information for them.
Internally, this just calls the correct class-specific collision functions
for @arg{o1} and @arg{o2}.

@arg{flags} specifies how contacts should be generated if the objects touch.
Currently the lower 8 bits of @arg{flags} specifies the maximum number of
contact points to generate.
If this number is zero, this function just pretends that it is one - in other
words you can not ask for zero contacts.
All other bits in @arg{flags} must be zero.
In the future the other bits may be used to select other contact generation
strategies.

@arg{contact} must point to an array of contact geometry information that
can hold at least the maximum number of contacts.
@emph{Note:} the elements of the @arg{contact} array do not necessarily have
to be contiguous.
@arg{skip} is the number of bytes between each @struct{dContactGeom}
structure in the @arg{contact} array.
If @arg{skip} is @c{sizeof(dContactGeom)} then @arg{contact} points to a
"normal" (C-style) contact array.
If skip is larger than this, then the @struct{dContactGeom} structures are
embedded in some other larger structures.
It is an error for @arg{skip} to be smaller than @c{sizeof(dContactGeom)}.

If the objects touch, this returns the number of contact points generated
(and updates the @arg{contact} array), otherwise it returns 0 (and the
@arg{contact} array is not touched).
}


@section{User defined classes}

You can define your own geometry classes using the functions in this section.
The standard geometry classes do not have any special access to the internals
of ODE, they use the public functions exactly as you would.

Every geometry class has a unique number (0,1,2, etc...).
A new geometry class (call it `X') must provide the following to ODE:
@numlist{
@*	Functions that will handle collision detection and contact generation
	between X and one or more other classes.
	These functions must be of type @c{dColliderFn}, which is defined as
	@code{@[
typedef int dColliderFn (dGeomID o1, dGeomID o2, int flags,
                         dContactGeom *contact, int skip);
	@]}
	This has exactly the same interface as @func{dCollide()}.
	Each function will handle a specific collision case, where @arg{o1}
	has type X and @arg{o2} has some other known type.

@*	A "selector" function, of type @c{dGetColliderFnFn}, which is
	defined as
	@code{@[
typedef dColliderFn * dGetColliderFnFn (int num);
	@]}
	This function takes a class number (@arg{num}), and returns the
	collider function that can handle colliding X with class @arg{num}.
	It should return 0 if X does not know how to collide with class
	@arg{num}.
	Note that if classes X and Y are to collide, only @emph{one} needs
	to provide a function to collide with the other.

	This function is called infrequently each @arg{num}, usually the
	return values are cached and reused.

@*	A function that will compute the axis aligned bounding box of
	instances of this class.
	This function must be of type @c{dGetAABBFn}, which is defined as
	@code{@[
typedef void dGetAABBFn (dGeomID g, dReal aabb[6]);
	@]}
	This function is given @arg{g}, which has type X, and returns the
	axis-aligned bounding box for @arg{g}.
	The @arg{aabb} array has elements
	@m{(minx, maxx, miny, maxy, minz, maxz)}.

@*	The number of bytes of "class data" that instances of this class
	need. For example a sphere store its radius in the class data area,
	and a box stores its side lengths there.
}

Here are the functions used to manage custom classes:


@funcdef{
int dCreateGeomClass (const dGeomClass *classptr);
}{
Register a new geometry class, defined by @arg{classptr}.
The number of the new class is returned.
The convention used in ODE is to assign the class number to a global variable
with the name @c{dXxxClass} where Xxx is the class name
(e.g. @c{dSphereClass}).

Here is the definition of the @c{dGeomClass} structure:
@code{@[
struct dGeomClass {
  int bytes;                  // bytes of custom data needed
  dGetColliderFnFn *collider; // collider function
  dGetAABBFn *aabb;           // bounding box function
};
@]}
}


@funcdef{
void * dGeomGetClassData (dGeomID);
}{
Given a geometry object, return a pointer to the class's custom data
(this will be a block of the required number of bytes).
Note that internal ODE classes use a faster macro instead.
}


@funcdef{
dGeomID dCreateGeom (dSpaceID space, int classnum);
}{
Create a geometry object of the given class number, and add it to the given
@arg{space}.
The custom data block will initially be set to 0.
}


@funcdef{
int dGeomGetClass (dGeomID);
}{
Given a geometry object, this returns its class number.
}


When you implement a new class you will usually write a function that does
the following:
@numlist{
@*	If the class has not yet been created, create it.
	You should be careful to only ever create the class once.
@*	Call @func{dCreateGeom()} to make an instance of the class.
@*	Set up the custom data area.
}
This is what @func{dCreateSphere()} and the other such functions do.


@section{Utility functions}


@funcdef{
int dBoxTouchesBox (const dVector3 _p1, const dMatrix3 R1,
                    const dVector3 side1, const dVector3 _p2,
                    const dMatrix3 R2, const dVector3 side2);
}{
Given boxes (@arg{p1},@arg{R1},@arg{side1}) and
(@arg{p2},@arg{R2},@arg{side2}), return 1 if they intersect or 0 if not.
@arg{p} is the center of the box, @arg{R} is the rotation matrix for
the box, and @arg{side} is a vector of x/y/z side lengths.
}


@section{Space}

A space is a container for geometry objects.
It is similar to the rigid body "world", except for collision instead of
dynamics.

The space does high level collision culling, which means that it can
identify which pairs of geometry objects are potentially touching.
You can safely call @func{dCollide()} for only those pairs, instead of
having to call @func{dCollide()} for @emph{every} object-object pair.
This can save a huge amount of time.
Various collision culling algorithms will be available, however only the
first is currently implemented:
@list{
@*	Simple @m{n^2} object intersections.
@*	Oct tree.
@*	Coordinate sorting.
@*	Hash table?
}

Here are the functions used for spaces:

@funcdef{
dSpaceID dSpaceCreate();
}{
Create a space.
}


@funcdef{
void dSpaceDestroy (dSpaceID);
}{
Destroy a space.
When a space is destroyed, all the geometry objects in that space are
automatically destroyed as well.
}


@funcdef{
void dSpaceAdd (dSpaceID, dGeomID);
void dSpaceRemove (dSpaceID, dGeomID);
}{
Add and remove geometry objects to/from the space.
These functions are normally only called by the geometry object
creation/deletion functions.
}


@funcdef{
void dSpaceCollide (dSpaceID space, void *data, dNearCallback *callback);
}{
Call a callback function one or more times, for all potentially intersecting
objects in the space.
The @arg{callback} function is of type @c{dNearCallback}, which is defined as:
@code{@[
typedef void dNearCallback (void *data, dGeomID o1, dGeomID o2);
@]}
The @arg{data} variable is passed from @func{dSpaceCollide()} to the
callback function. Its meaning is user defined.
The @arg{o1} and @arg{o2} arguments are the geometry objects that may be near
each other.
The callback function can call @func{dCollide()} on @arg{o1} and @arg{o2},
perhaps first determining whether to collide them at all based on other
information.
}


@section{Future}

Future interface enhancements:
@list{
@*	Composite objects.
}

#############################################################################
@chapter{How to make good simulations}

[Just notes for now]

@list{
@*	Don't collide objects that are joined together.
@*	Describe all factors that affect speed.
@*	Use powered joint, joint limits, built-in springs as much as possible,
	avoid explicit forces.
}

#############################################################################
@chapter{Known BUGS}

@list{
@*	When assigning a mass to a rigid body, the center of mass must be
	(0,0,0) relative to the body's position.
}

#############################################################################
@chapter{Appendix A: Matrix storage conventions}

Matrix operations like factorization are expensive, so we must store the data
in a way that is most useful to the matrix code.
I want to do 4-way SIMD optimizations later, so the format is this: store
the matrix by rows, and each row is rounded up to a multiple of 4 elements.
The extra "padding" elements at the end of each row/column must be set
to 0.
This is called the "standard format".
Hopefully this decision will remain good in the future, as more and
more processors have 4-way SIMD (especially for fast 3D graphics).

The exception: matrices that have only one column or row (vectors), are always
stored as consecutive elements in standard row format, i.e. there is no
interior padding, only padding at the end.

Thus: all 3x1 floating point vectors are stored as 4x1 vectors: (x,x,x,0).

#############################################################################
@chapter{ODE internals}

[only notes for now]

@list{

@*	Internally, all 6x1 spatial velocities and accelerations are split
	into 3x1 position and angular components, which are stored as
	contiguous 4x1 vectors.

@*	Lagrange multiplier velocity based model due to Trinkle and Stewart.
@*	Friction due to Baraff.

@*	Stability over accuracy.

@*	Talk about the different methods possible.
	Say how realtime constraints make the problem much more difficult.

@*	Factorizer.

@*	LCP solver.

@*	Equations of motion.
}
