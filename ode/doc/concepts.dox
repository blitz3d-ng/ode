/**
@page concepts Basic Concepts

@section Background

[Here is where I will write some background information about rigid body 
dynamics and simulation. But in the meantime, please refer to Baraff's 
excellent 
<a href="http://www.cs.cmu.edu/~baraff/sigcourse/index.html">SIGGRAPH tutorial</a>].

@section Rigid Bodies

A rigid body has various properties from the point of view of the simulation. 
Some properties change over time:

@li Position vector (x,y,z) of the body's point of reference. Currently the point of reference must correspond to the body's center of mass.
@li Linear velocity of the point of reference, a vector (vx,vy,vz).
@li Orientation of a body, represented by a quaternion (qs,qx,qy,qz) or a 3x3 rotation matrix.
@li Angular velocity vector (wx,wy,wz) which describes how the orientation changes over time.

Other body properties are usually constant over time:

@li Mass of the body.
@li Position of the center of mass with respect to the point of reference. In the current implementation the center of mass and the point of reference must coincide.
@li Inertia matrix. This is a 3x3 matrix that describes how the body's mass is distributed around the center of mass. 

Conceptually each body has an x-y-z coordinate frame embedded in it, that 
moves and rotates with the body, as shown in figure 1.

@image html body.jpg "Figure 1. The body coordinate frame"

The origin of this coordinate frame is the body's point of reference. Some 
values in ODE (vectors, matrices etc) are relative to the body coordinate 
frame, and others are relative to the global coordinate frame.

Note that the <em>shape</em> of a rigid body is not a dynamical property (except 
insofar as it influences the various mass properties). It is only <em>collision 
detection</em> that cares about the detailed shape of the body.

@subsection islands Islands and Disabled Bodies

Bodies are connected to each other with joints. An "island" of bodies is a 
group that can not be pulled apart - in other words each body is connected 
somehow to every other body in the island.

Each island in the world is treated separately when the simulation step is 
taken. This is useful to know: if there are N similar islands in the 
simulation then the step computation time will be O(N).

Each body can be enabled or disabled. Disabled bodies are effectively 
"turned off" and are not updated during a simulation step. Disabling 
bodies is an effective way to save computation time when it is known that 
the bodies are motionless or otherwise irrelevant to the simulation.

If there are any enabled bodies in an island then every body in the island 
will be enabled at the next simulation step. Thus to effectively disable an 
island of bodies, every body in the island must be disabled. If a disabled 
island is touched by another enabled body then the entire island will be 
enabled, as a contact joint will join the enabled body to the island.


@section integration Integration

The process of simulating the rigid body system through time is called 
integration. Each integration step advances the current time by a given step 
size, adjusting the state of all the rigid bodies for the new time value. 
There are two main issues to consider when working with any integrator:

@li How accurate is it? That is, how closely does the behavior of the simulated system match what would happen in real life?
@li How stable is it? That is, will calculation errors ever cause completely non-physical behavior of the simulated system? (e.g. causing the system to "explode" for no reason). 

ODE's current integrator is very stable, but not particularly accurate 
unless the step size is small. For most uses of ODE this is not a problem &mdash; 
ODE's behavior still looks perfectly physical in almost all cases. However ODE 
should not be used for quantitative engineering until this accuracy issue has 
been addressed in a future release.


@section force_accumulators Force accumulators

Between each integrator step the user can call functions to apply forces to 
the rigid body. These forces are added to "force accumulators" in the rigid 
body object. When the next integrator step happens, the sum of all the applied 
forces will be used to push the body around. The forces accumulators are set 
to zero after each integrator step.


@section joints_and_constraints Joints and constraints

In real life a joint is something like a hinge, that is used to connect two 
objects. In ODE a joint is very similar: It is a relationship that is enforced 
between two bodies so that they can only have certain positions and 
orientations relative to each other. This relationship is called a 
<em>constraint</em> &mdash; the words <em>joint</em> and <em>constraint</em>
are often used interchangeably. Figure 2 shows three different constraint 
types.

@image html joints.jpg "Figure 2. Three different constraint types"

The first is a ball and socket joint that constraints the "ball" of one body to 
be in the same location as the "socket" of another body. The second is a hinge 
joint that constraints the two parts of the hinge to be in the same location and 
to line up along the hinge axle. The third is a slider joint that constraints 
the "piston" and "socket" to line up, and additionally constraints the two bodies 
to have the same orientation.

Each time the integrator takes a step all the joints are allowed to apply 
<em>constraint forces</em> to the bodies they affect. These forces are calculated such 
that the bodies move in such a way to preserve all the joint relationships.

Each joint has a number of parameters controlling its geometry. An example is 
the position of the ball-and-socket point for a ball-and-socket joint. The 
functions to set joint parameters all take <em>global</em> coordinates, not 
body-relative coordinates. A consequence of this is that the rigid bodies 
that a joint connects must be positioned correctly <em>before</em> the joint is 
attached.


@section joint_groups Joint groups

A joint group is a special container that holds joints in a world. Joints can be 
added to a group, and then when those joints are no longer needed the entire group 
of joints can be very quickly destroyed with one function call. However, individual 
joints in a group can not be destroyed before the entire group is emptied.

This is most useful with contact joints, which are added and remove from the world 
in groups every time step.


@section joint_error Joint error and the error reduction parameter (ERP)

When a joint attaches two bodies, those bodies are required to have certain 
positions and orientations relative to each other. However, it is possible 
for the bodies to be in positions where the joint constraints are not met. 
This "joint error" can happen in two ways:

<ol>
<li>If the user sets the position/orientation of one body without correctly setting the position/orientation of the other body.</li>
<li>During the simulation, errors can creep in that result in the bodies drifting away from their required positions.</li>
</ol>

Figure 3 shows an example of error in a ball and socket joint (where the ball 
and socket do not line up).

@image html ball-and-socket-bad.jpg "Figure 3. An example of error in a ball and socket joint"

There is a mechanism to reduce joint error: during each simulation step each 
joint applies a special force to bring its bodies back into correct alignment. 
This force is controlled by the <em>error reduction parameter</em> (ERP), 
which has a value between 0 and 1.

The ERP specifies what proportion of the joint error will be fixed during the 
next simulation step. If ERP=0 then no correcting force is applied and the 
bodies will eventually drift apart as the simulation proceeds. If ERP=1 then 
the simulation will attempt to fix all joint error during the next time step. 
However, setting ERP=1 is not recommended, as the joint error will not be 
completely fixed due to various internal approximations. A value of 
ERP=0.1 to 0.8 is recommended (0.2 is the default).

A global ERP value can be set that affects most joints in the simulation. 
However some joints have local ERP values that control various aspects 
of the joint.

@section soft_constraints Soft constraint and constraint force mixing (CFM)

Most constraints are by nature "hard". This means that the constraints 
represent conditions that are never violated. For example, the ball must 
always be in the socket, and the two parts of the hinge must always be 
lined up. In practice constraints can be violated by unintentional 
introduction of errors into the system, but the error reduction parameter 
can be set to correct these errors.

Not all constraints are hard. Some "soft" constraints are designed to be 
violated. For example, the contact constraint that prevents colliding 
objects from penetrating is hard by default, so it acts as though the 
colliding surfaces are made of steel. But it can be made into a soft 
constraint to simulate softer materials, thereby allowing some natural 
penetration of the two objects when they are forced together.

There are two parameters that control the distinction between hard and 
soft constraints. The first is the error reduction parameter (ERP) that 
has already been introduced. The second is the constraint force mixing 
(CFM) value, that is described below.

@subsection constraint_force_mixing Constraint Force Mixing (CFM)

What follows is a somewhat technical description of the meaning of CFM. 
If you just want to know how it is used in practice then skip to the 
next section.

Traditionally the constraint equation for every joint has the form

<center><em>J * v = c</em></center>

where <em>v</em> is a velocity vector for the bodies involved, <em>J</em> 
is a "Jacobian" matrix with one row for every degree of freedom the joint 
removes from the system, and <em>c</em> is a right hand side vector. At 
the next time step, a vector <em>lambda</em> is calculated (of the same 
size as <em>c</em>) such that the forces applied to the bodies to preserve 
the joint constraint are

<center><em>force = JT * lambda</em></center>

ODE adds a new twist. ODE's constraint equation has the form

<center><em>J * v = c + CFM * lambda</em></center>

where <em>CFM</em> is a square diagonal matrix. <em>CFM</em> mixes the 
resulting constraint force in with the constraint that produces it. A 
nonzero (positive) value of <em>CFM</em> allows the original constraint 
equation to be violated by an amount proportional to CFM times the 
restoring force lambda that is needed to enforce the constraint. 
Solving for <em>lambda</em> gives

<center><em>(J M-1 JT + CFM/h) lambda = c/h</em></center>

Thus CFM simply adds to the diagonal of the original system matrix. Using a 
positive value of CFM has the additional benefit of taking the system away 
from any singularity and thus improving the factorizer accuracy.

@subsection erp_and_cfm How To Use ERP and CFM

ERP and CFM can be independently set in many joints. They can be set in 
contact joints, in joint limits and various other places, to control the 
spongyness and springyness of the joint (or joint limit).

If CFM is set to zero, the constraint will be hard. If CFM is set to a 
positive value, it will be possible to violate the constraint by "pushing 
on it" (for example, for contact constraints by forcing the two 
contacting objects together). In other words the constraint will be soft, 
and the softness will increase as CFM increases. What is actually happening 
here is that the constraint is allowed to be violated by an amount 
proportional to CFM times the restoring force that is needed to enforce the 
constraint. Note that setting CFM to a negative value can have undesirable 
bad effects, such as instability. Don't do it.

By adjusting the values of ERP and CFM, you can achieve various effects. 
For example you can simulate springy constraints, where the two bodies 
oscillate as though connected by springs. Or you can simulate more spongy 
constraints, without the oscillation. In fact, ERP and CFM can be selected 
to have the same effect as any desired spring and damper constants. If you 
have a spring constant kp and damping constant kd, then the corresponding 
ODE constants are:

<center><em>ERP = h kp / (h kp + kd)</em></center>
<center><em>CFM = 1 / (h kp + kd)</em></center>

where h is the stepsize. These values will give the same effect as a 
spring-and-damper system simulated with implicit first order integration.

Increasing CFM, especially the global CFM, can reduce the numerical errors 
in the simulation. If the system is near-singular, then this can markedly 
increase stability. In fact, if the system is mis-behaving, one of the 
first things to try is to increase the global CFM.

*/
